#!/usr/bin/env python

import sys
import numpy as np
import os
import itertools
import pickle
from os.path import expanduser
import psutil
import pprint

from addie.ipythondockwidget import IPythonDockWidget

try:
    from PyQt4.QtGui import QDialog, QTreeWidgetItem, QTableWidgetItem, QMenu
    from PyQt4 import QtCore, QtGui
except ImportError:
    try:
        from PyQt5.QtWidgets import QDialog, QTreeWidgetItem, QTableWidgetItem, QMenu
        from PyQt5 import QtCore, QtGui
    except ImportError:
        raise ImportError("Requires PyQt4 or PyQt5")

import addie.ui_mainWindow
import addie.ui_table_tree
import addie.step1
import addie.step2

from addie.about import AboutDialog
from addie.advanced_window_handler.advanced_window import AdvancedWindowLauncher
from addie.make_calibration_handler.make_calibration import MakeCalibrationLauncher
from addie.configuration.export_configuration import ExportConfiguration
from addie.configuration.import_configuration import ImportConfiguration

from addie.general_handler.help_gui import HelpGui, help_button_activator

from addie.utilities.job_status_handler import JobStatusHandler
from addie.utilities.job_monitor_thread import JobMonitorThread
from addie.utilities.logbook_thread import LogbookThread
from addie.utilities.logbook_handler import LogbookHandler
from addie.utilities.ipts_file_transfer_dialog import IptsFileTransferDialog

from addie.initialization.init_step1 import InitStep1

from addie.step1_handler.step1_gui_handler import Step1GuiHandler
from addie.step1_handler.run_step1 import RunStep1
from addie.step2_handler.load_table_intermediate_step_interface import loadTableIntermediateStepInterface
from addie.step2_handler.undo_handler import UndoHandler

from addie.initialization.init_step2 import InitStep2
from addie.step2_handler.populate_master_table import PopulateMasterTable
from addie.step2_handler.populate_background_widgets import PopulateBackgroundWidgets
from addie.step2_handler.step2_gui_handler import Step2GuiHandler
from addie.step2_handler.table_handler import TableHandler
from addie.step2_handler.create_sample_files import CreateSampleFiles
from addie.step2_handler.create_ndsum_file import CreateNdsumFile
from addie.step2_handler.run_ndabs import RunNDabs
from addie.step2_handler.run_sum_scans import RunSumScans
from addie.step2_handler.run_thread import RunThread

from addie.step3_handler.step3_gui_handler import Step3GuiHandler

from addie.mantid_handler.browse_file_folder_handler import BrowseFileFolderHandler
from addie.mantid_handler.mantid_reduction import GlobalMantidReduction
from addie.mantid_handler.mantid_thread import MantidThread

from addie.master_table.table_tree_handler import TableTreeHandler, TableInitialization
from addie.master_table.tree_definition import *
from addie.ui_table_tree_save_config import Ui_Dialog as UiDialogSave

import PyQt4
import PyQt4.QtCore as QtCore
import PyQt4.QtGui as QtGui

import addie.addiedriver as driver
import addie.specify_plots_style as ps
import addie.edit_sq_dialog

from addie.pdf_lines_manager import PDFPlotManager

user_home = expanduser("~")
CONFIG_FILE = os.path.join(user_home, '.addie_config.cfg')


class MainWindow(PyQt4.QtGui.QMainWindow, addie.ui_mainWindow.Ui_MainWindow):
    """ Main addie window
    """

    # external ui (use to make sure there is only one open at a time
    advanced_window_ui = None
    make_calibration_ui = None
    table_tree_ui = None
    table_tree_ui_position = None

    # configuration of master table
    config_dict = OrderedDict()
    reset_config_dict = OrderedDict()
    active_config_name = ''
    list_config_displayed = []

    table_headers = {'h1': [],
                     'h2': [],
                     'h3': [],
                     }

    table_width = {'h1': [],
                   'h2': [],
                   'h3': []}

    # to find which h1 column goes with wich h2 and which h3
    table_columns_links = {'h1': [],
                           'h2': [],
                           'h3': [],
                           }

    tree_dict = None
    tree_ui = None
    minimum_col_width = 10

    # headers from master table
    h1_header_table = None
    h2_header_table = None
    h3_header_table = None

    undo_table = {}
    max_undo_list = 10
    undo_index = max_undo_list
    undo_button_enabled = False
    redo_button_enabled = False
    post_processing = 'idl'  # or 'mantid'
    cache_folder = './' # defined in the advanced window
    output_folder = './' # defined in the advanced window

    debugging = False
    load_intermediate_step_ok = False
    remove_dynamic_temperature_flag = False
    current_folder = os.getcwd()
    configuration_folder = current_folder
    calibration_folder = '/SNS/lustre/NOM/shared/CALIBRATION/2016_2_1B_CAL/'
    characterization_folder = '/SNS/lustre/NOM/shared/CALIBRATION/2016_2_1B_CAL/'
    file_path = os.getcwd()
    table_selection_buffer = {}
    _run_thread_sum_scans = RunThread()

    logbook_thread = LogbookThread()
    number_of_last_log_files_to_display = 10
    previous_list_of_log_files = []

    _run_thread = RunThread()
    job_monitor_thread = JobMonitorThread()
    _mantid_thread_array = list(itertools.repeat(MantidThread(), 30))
    config_section_name = 'Configuration'
    job_monitor_interface = None
    logbook_interface = None
    job_list = []

    init_height_main_gui = 1058
    previous_splitter_height = -1
    first_time_resizing_blocked = True

    o_help_autonom = None
    o_help_ndabs = None
    o_help_scans = None
    o_help_mantid = None

    def __init__(self):
        """ Initialization
        Parameters
        ----------
        """
        # Base class
        QtGui.QMainWindow.__init__(self)

        if self.debugging:
            self.calibration_folder = '/SNS/NOM/IPTS-17118/shared/'
            self.characterization_folder = '/SNS/NOM/shared/CALIBRATION/'

        # Initialize the UI widgets
        self.ui = addie.ui_mainWindow.Ui_MainWindow()
        self.ui.setupUi(self)
        self.ui.graphicsView_sq.set_main(self)

        self.ui.dockWidget_ipython.setup()

        # set widgets
        self._init_widgets()
        init_step1 = InitStep1(parent=self)
        init_step2 = InitStep2(parent=self)
        self.init_master_table()

        # define the event handling methods

        # bragg diffraction tab
        self.connect(self.ui.pushButton_loadBraggFile, QtCore.SIGNAL('clicked()'),
                     self.do_load_bragg_file)
        self.connect(self.ui.checkBox_bank1, QtCore.SIGNAL('toggled(bool)'),
                     self.evt_plot_bragg_bank)
        self.connect(self.ui.checkBox_bank2, QtCore.SIGNAL('toggled(bool)'),
                     self.evt_plot_bragg_bank)
        self.connect(self.ui.checkBox_bank3, QtCore.SIGNAL('toggled(bool)'),
                     self.evt_plot_bragg_bank)
        self.connect(self.ui.checkBox_bank4, QtCore.SIGNAL('toggled(bool)'),
                     self.evt_plot_bragg_bank)
        self.connect(self.ui.checkBox_bank5, QtCore.SIGNAL('toggled(bool)'),
                     self.evt_plot_bragg_bank)
        self.connect(self.ui.checkBox_bank6, QtCore.SIGNAL('toggled(bool)'),
                     self.evt_plot_bragg_bank)
        self.connect(self.ui.comboBox_xUnit, QtCore.SIGNAL('currentIndexChanged(int)'),
                     self.evt_switch_bragg_unit)
        self.connect(self.ui.radioButton_multiBank, QtCore.SIGNAL('toggled(bool)'),
                     self.evt_change_gss_mode)

        self.connect(self.ui.pushButton_rescaleGSAS, QtCore.SIGNAL('clicked()'),
                     self.do_rescale_bragg)

        self.connect(self.ui.pushButton_gsasColorStyle, QtCore.SIGNAL('clicked()'),
                     self.do_set_bragg_color_marker)
        self.connect(self.ui.pushButton_clearBraggCanvas, QtCore.SIGNAL('clicked()'),
                     self.do_clear_bragg_canvas)

        # for tab G(R)
        self.connect(self.ui.pushButton_loadSQ, QtCore.SIGNAL('clicked()'),
                     self.do_load_sq)
        self.connect(self.ui.comboBox_SofQType, QtCore.SIGNAL('currentIndexChanged(int)'),
                     self.evt_change_sq_type)
        self.connect(self.ui.pushButton_clearSofQ, QtCore.SIGNAL('clicked()'),
                     self.do_clear_sq)
        self.connect(self.ui.pushButton_showQMinMax, QtCore.SIGNAL('clicked()'),
                     self.do_show_sq_bound)
        self.connect(self.ui.pushButton_generateGR, QtCore.SIGNAL('clicked()'),
                     self.do_generate_gr)
        self.connect(self.ui.pushButton_loadGofR, QtCore.SIGNAL('clicked()'),
                     self.do_load_gr)
        self.connect(self.ui.pushButton_saveGR, QtCore.SIGNAL('clicked()'),
                     self.do_save_gr)
        self.connect(self.ui.pushButton_clearGrCanvas, QtCore.SIGNAL('clicked()'),
                     self.do_clear_gr)
        self.connect(self.ui.pushButton_saveSQ, QtCore.SIGNAL('clicked()'),
                     self.do_save_sq)
        self.connect(self.ui.pushButton_editSofQ, QtCore.SIGNAL('clicked()'),
                     self.do_edit_sq)
        self.connect(self.ui.pushButton_generateSQ, QtCore.SIGNAL('clicked()'),
                     self.do_generate_sq)

        self.connect(self.ui.doubleSpinBoxQmin, QtCore.SIGNAL('valueChanged(double)'),
                     self.evt_qmin_changed)
        self.connect(self.ui.doubleSpinBoxQmax, QtCore.SIGNAL('valueChanged(double)'),
                     self.evt_qmax_changed)

        self.connect(self.ui.pushButton_rescaleSq, QtCore.SIGNAL('clicked()'),
                     self.do_rescale_sofq)
        self.connect(self.ui.pushButton_rescaleGr, QtCore.SIGNAL('clicked()'),
                     self.do_rescale_gofr)

        self.connect(self.ui.pushButton_grColorStyle, QtCore.SIGNAL('clicked()'),
                     self.do_set_gofr_color_marker)
        self.connect(self.ui.pushButton_sqColorStyle, QtCore.SIGNAL('clicked()'),
                     self.do_set_sq_color_marker)

        #  menu operations
        self.connect(self.ui.actionReset_GofR_tab, QtCore.SIGNAL('triggered()'),
                     self.do_reset_gr_tab)
        self.connect(self.ui.actionReset_GSAS_tab, QtCore.SIGNAL('triggered()'),
                     self.do_reset_gsas_tab)
        self.connect(self.ui.actionQuit, QtCore.SIGNAL('triggered()'),
                     self.evt_quit)
        self.connect(self.ui.actionCheat_sheet, QtCore.SIGNAL('triggered()'),
                     self.do_show_help)

        # organize widgets group
        self._braggBankWidgets = {1: self.ui.checkBox_bank1,
                                  2: self.ui.checkBox_bank2,
                                  3: self.ui.checkBox_bank3,
                                  4: self.ui.checkBox_bank4,
                                  5: self.ui.checkBox_bank5,
                                  6: self.ui.checkBox_bank6}
        self._braggBankWidgetRecords = dict()
        for bank_id in self._braggBankWidgets.keys():
            checked = self._braggBankWidgets[bank_id].isChecked()
            self._braggBankWidgetRecords[bank_id] = checked

        # define the driver
        self._myController = driver.AddieDriver()

        # class variable for easy access
        self._gssGroupName = None
        self._currDataDir = None
        self._inFixedDirectoryStructure = False
        self._currWorkDir = os.getcwd()

        # some controlling variables
        self._currBraggXUnit = str(self.ui.comboBox_xUnit.currentText())
        if self._currBraggXUnit == 'Q':
            self._currBraggXUnit = 'MomentumTransfer'
        self._onCanvasGSSBankList = list()

        # mutex-like variables
        self._noEventBankWidgets = False

        # help (refer to DGSPlanner and HFIR Powder reduction GUI)
        self._assistantProcess = QtCore.QProcess(self)

        # a collection of sub window
        self._editSqDialog = None
        self._editedSofQDict = dict()

        # color management
        self._pdfColorManager = PDFPlotManager()

        self.save_raw_config()

        return

    def save_raw_config(self):
        '''this will allow the user to reset the full table and get it back in its initial state'''
        o_current_table_config = TableConfig(parent=self)
        current_config = o_current_table_config.get_current_config()

        inside_dict = OrderedDict()
        inside_dict['table'] = current_config
        inside_dict['active'] = False

        self.reset_config_dict = inside_dict

    def init_master_table(self):
        o_table = TableInitialization(parent=self)
        o_table.init_master_table()
        o_table.init_signals()

    def _init_widgets(self):
        """ Initialize widgets
        Returns
        -------

        """

        #init_size_splitter = self.ui.splitter.size()
        #self.init_size_splitter_height = init_size_splitter.height()
        #init_width = self.size()
        #self.init_width = init_width.width()

        self.ui.splitter.setStyleSheet("""
	QSplitter::handle {
	   image: url(':/MPL Toolbar/splitter_icon.png');
	}
	""")

        self.ui.comboBox_xUnit.clear()
        self.ui.comboBox_xUnit.addItems(['TOF', 'dSpacing', 'Q'])
        index = self.ui.comboBox_xUnit.findText('dSpacing',QtCore.Qt.MatchFixedString)
        self.ui.comboBox_xUnit.setCurrentIndex(index)

        self.ui.treeWidget_braggWSList.set_main_window(self)
        self.ui.treeWidget_braggWSList.add_main_item('workspaces', append=True, as_current_index=False)

        self.ui.treeWidget_grWsList.set_main_window(self)
        self.ui.treeWidget_grWsList.add_main_item('workspaces', append=True, as_current_index=False)
        self.ui.treeWidget_grWsList.add_main_item('SofQ', append=True, as_current_index=False)

        self.ui.dockWidget_ipython.iPythonWidget.set_main_application(self)

        self.ui.comboBox_SofQType.clear()
        self.ui.comboBox_SofQType.addItem('S(Q)')
        self.ui.comboBox_SofQType.addItem('S(Q)-1')
        self.ui.comboBox_SofQType.addItem('Q[S(Q)-1]')
        self.ui.comboBox_SofQType.setCurrentIndex(0)

        self.ui.radioButton_multiBank.setChecked(True)

        # add the combo box for PDF type
        self.ui.comboBox_pdfType.addItems(['G(r)', 'g(r)', 'RDF(r)'])

        # some starting value
        self.ui.doubleSpinBoxDelR.setValue(0.01)

        # set a constant item to combobox Sq
        self.ui.comboBox_SofQ.addItem('All')

        # PDF filter
        self.ui.comboBox_pdfCorrection.clear()
        self.ui.comboBox_pdfCorrection.addItem('No Modification')
        self.ui.comboBox_pdfCorrection.addItem('Lorch')

        # set the tab to 0
        self.ui.main_tab.setCurrentIndex(0)

        # set the lower limit on Qmin
        self.ui.doubleSpinBoxQmin.setDecimals(6)
        self.ui.doubleSpinBoxQmin.setMinimum(1.E-10)

        return

    @property
    def controller(self):
        """
        get handler of controller
        :return:
        """
        return self._myController

    def do_set_bragg_color_marker(self):
        """
        set the color/marker to plots on bragg canvas
        :return:
        """
        # get the current figure' on-shown plots
        plot_id_label_list = self.ui.graphicsView_bragg.get_current_plots()

        # get the line ID, color, and marker
        plot_id_list, color, marker = ps.get_plots_color_marker(self, plot_label_list=plot_id_label_list)
        if plot_id_list is None:
            # operation is cancelled by user
            pass
        else:
            # set the color and mark
            for plot_id in plot_id_list:
                self.ui.graphicsView_bragg.updateLine(ikey=plot_id, linecolor=color, marker=marker,
                                                      markercolor=color)

        return

    def do_set_gofr_color_marker(self):
        """
        set the color/marker to plots on G(r) canvas
        :return:
        """
        # get the line ID, color, and marker
        plot_id_label_list = self.ui.graphicsView_gr.get_current_plots()

        # get the line ID, color, and marker
        plot_id_list, color, marker = ps.get_plots_color_marker(self, plot_label_list=plot_id_label_list)
        if plot_id_list is None:
            # operation is cancelled by user
            pass
        else:
            # set the color and mark
            for plot_id in plot_id_list:
                self.ui.graphicsView_gr.updateLine(ikey=plot_id, linecolor=color, marker=marker,
                                                   markercolor=color)

        return

    def do_set_sq_color_marker(self):
        """
        set the color/marker on S(q) canvas
        Returns:

        """
        # get the line ID, color, and marker
        plot_id_label_list = self.ui.graphicsView_sq.get_current_plots()

        # get the line ID, color, and marker
        plot_id_list, color, marker = ps.get_plots_color_marker(self, plot_label_list=plot_id_label_list)
        if plot_id_list is None:
            # operation is cancelled by user
            pass
        else:
            # set the color and mark
            for plot_id in plot_id_list:
                self.ui.graphicsView_sq.updateLine(ikey=plot_id, linecolor=color, marker=marker,
                                                   markercolor=color)

        return

    def do_show_help(self):
        """ Show help
        Copied from DGSPlanner
        """
        # close previous service
        self._assistantProcess.close()
        self._assistantProcess.waitForFinished()

        # launch
        # helper_url = QtCore.QUrl('addie_helper.html')
        helper_url = QtCore.QUrl('https://neutrons.github.io/addie/index.html')
        QtGui.QDesktopServices.openUrl(helper_url)

        return

    def do_clear_bragg_canvas(self):
        """
        Clear all the plots on Bragg-canvas
        Returns
        -------

        """
        self.ui.graphicsView_bragg.reset()
        self.clear_bank_checkboxes()
        self._onCanvasGSSBankList = list()

        return

    def do_clear_gr(self):
        """
        Clear G(r) canvas
        Returns
        -------

        """
        self.ui.graphicsView_gr.reset()

        return

    def do_clear_sq(self):
        """
        Remove all lines from S(Q) canvas
        Returns
        -------

        """
        self.ui.graphicsView_sq.reset()

        return

    def do_generate_gr(self):
        """ Handling event from push button 'Generate G(r)' by generating G(r) of selected workspaces
        :return:
        """
        # get S(Q) workspace
        selected_sq = str(self.ui.comboBox_SofQ.currentText())
        if selected_sq == 'All':
            sq_ws_name_list = list()
            for index in range(self.ui.comboBox_SofQ.count()):
                item = str(self.ui.comboBox_SofQ.itemText(index))
                if item != 'All':
                    # add S(Q) name unless it is 'All'
                    sq_ws_name_list.append(item)
                # END-IF
            # END-FOR
        else:
            # selected S(Q) is a single S(Q) name
            sq_ws_name_list = [selected_sq]

        # generate G(r)
        self.generate_gr(sq_ws_name_list=sq_ws_name_list)

        return

    def generate_gr(self, sq_ws_name_list):
        """Generate G(r) from specified S(Q) workspaces
        :param sq_ws_name_list:
        :return:
        """
        # check inputs
        assert isinstance(sq_ws_name_list, list), 'S(Q) workspaces {0} must be given by list but not {1}.' \
                                                  ''.format(sq_ws_name_list, type(sq_ws_name_list))
        if len(sq_ws_name_list) == 0:
            raise RuntimeError('User specified an empty list of S(Q)')

        # get r-range and q-range
        min_r = float(self.ui.doubleSpinBoxRmin.value())
        max_r = float(self.ui.doubleSpinBoxRmax.value())
        delta_r = float(self.ui.doubleSpinBoxDelR.value())

        min_q = float(self.ui.doubleSpinBoxQmin.value())
        max_q = float(self.ui.doubleSpinBoxQmax.value())

        use_filter_str = str(self.ui.comboBox_pdfCorrection.currentText())
        if use_filter_str == 'No Modification':
            pdf_filter = None
        elif use_filter_str == 'Lorch':
            pdf_filter = 'lorch'
        else:
            raise RuntimeError('PDF filter {0} is not recognized.'.format(use_filter_str))
        rho0_str = str(self.ui.lineEdit_rho.text())
        if rho0_str.isdigit():
            rho0 = float(rho0_str)
        else:
            rho0 = None

        # PDF type
        pdf_type = str(self.ui.comboBox_pdfType.currentText())

        # loop for all selected S(Q)
        for sq_ws_name in sq_ws_name_list:
            # calculate G(r)
            gr_ws_name = self._myController.calculate_gr(sq_ws_name, pdf_type, min_r, delta_r, max_r,
                                                         min_q, max_q, pdf_filter, rho0)

            # check whether G(r) is on GofR plot or not in order to determine this is an update or new plot
            update = self.ui.graphicsView_gr.has_gr(gr_ws_name)

            # plot G(R)
            if not update:
                # a new line
                gr_color, gr_style, gr_marker, gr_alpha = self._pdfColorManager.add_gofr(sq_ws_name, gr_ws_name, max_q)
                gr_label = '{0} Q: ({1}, {2})'.format(sq_ws_name, min_q, max_q)
                self.plot_gr(gr_ws_name, gr_color, gr_style, gr_marker, gr_alpha, gr_label)
            else:
                self.plot_gr(gr_ws_name, gr_line_color=None, gr_line_style=None, gr_line_marker=None,
                             gr_line_alpha=None, gr_line_label=None)

            # add to tree
            # TODO/ISSUE/NOW - Need to find out the name of the
            gr_param_str = 'G(r) for Q(%.3f, %.3f)' % (min_q, max_q)
            self.ui.treeWidget_grWsList.add_gr(gr_param_str, gr_ws_name)
        # END-FOR

        return

    def do_rescale_bragg(self):
        """ Rescale the figure of Bragg diffraction data
        :return:
        """
        min_y_value = self.ui.graphicsView_bragg.get_y_min()
        max_y_value = self.ui.graphicsView_bragg.get_y_max()
        delta_y = max(1, max_y_value - min_y_value)

        y_lower_limit = min_y_value - delta_y * 0.05
        y_upper_limit = max_y_value + delta_y * 0.05

        self.ui.graphicsView_bragg.setXYLimit(ymin=y_lower_limit, ymax=y_upper_limit)

        return

    def do_rescale_sofq(self):
        """ Rescale the figure of S(Q)
        :return:
        """
        min_y_value = self.ui.graphicsView_sq.get_y_min()
        max_y_value = self.ui.graphicsView_sq.get_y_max()
        delta_y = max(1, max_y_value - min_y_value)

        y_lower_limit = min_y_value - delta_y * 0.05
        y_upper_limit = max_y_value + delta_y * 0.05

        self.ui.graphicsView_sq.setXYLimit(ymin=y_lower_limit, ymax=y_upper_limit)

        return

    def do_rescale_gofr(self):
        """ Rescale the figure of G(r)
        :return:
        """
        min_y_value = self.ui.graphicsView_gr.get_y_min()
        max_y_value = self.ui.graphicsView_gr.get_y_max()
        delta_y = max(1, max_y_value - min_y_value)

        y_lower_limit = min_y_value - delta_y * 0.05
        y_upper_limit = max_y_value + delta_y * 0.05

        self.ui.graphicsView_gr.setXYLimit(ymin=y_lower_limit, ymax=y_upper_limit)

        return

    def do_reset_gr_tab(self):
        """
        Reset G(r)-tab, including deleting all the G(r) and S(Q) workspaces,
        clearing the G(r) and S(Q) trees, and clearing both G(r) and S(Q) canvas
        Returns:
        None
        """
        # get workspace from trees
        workspace_list = self.ui.treeWidget_grWsList.get_workspaces()

        # reset the tree to initial status
        self.ui.treeWidget_grWsList.reset_gr_tree()

        # delete all the workspaces
        for workspace in workspace_list:
            self._myController.delete_workspace(workspace)

        # clear all the canvas
        self.ui.graphicsView_gr.clear_all_lines()
        self.ui.graphicsView_sq.clear_all_lines()

        # clear the S(Q) combo box
        self.ui.comboBox_SofQ.clear()
        self.ui.comboBox_SofQ.addItem('All')


        return

    def do_reset_gsas_tab(self):
        """
        Reset the GSAS-tab including
        1. deleting all the GSAS workspaces
        2. clearing the GSAS tree
        3. clearing GSAS canvas
        Returns:
        None
        """
        # delete all workspaces: get GSAS workspaces from tree
        gsas_group_node_list = self.ui.treeWidget_braggWSList.get_main_nodes(output_str=False)
        for gsas_group_node in gsas_group_node_list:
            # skip if the workspace is 'workspaces'
            gss_node_name = str(gsas_group_node.text())
            if gss_node_name == 'workspaces':
                continue
            # get the split workspaces' names and delete
            gsas_ws_name_list = self.ui.treeWidget_braggWSList.get_child_nodes(gsas_group_node, output_str=True)
            for workspace in gsas_ws_name_list:
                self._myController.delete_workspace(workspace)
            # END-FOR

            # guess for the main workspace and delete
            gss_main_ws = gss_node_name.split('_group')[0]
            self._myController.delete_workspace(gss_main_ws, no_throw=True)

        # END-FOR (gsas_group_node)

        # reset the GSAS tree
        self.ui.treeWidget_braggWSList.reset_bragg_tree()

        # clear checkboxes for banks
        self.clear_bank_checkboxes()

        # clear the canvas
        self.ui.graphicsView_bragg.reset()

        return

    def clear_bank_checkboxes(self):
        self._noEventBankWidgets = True
        for check_box in self._braggBankWidgets.values():
            check_box.setChecked(False)
        self._noEventBankWidgets = False

        return

    def plot_bragg(self, bragg_ws_list,  clear_canvas=False):
        """
        Parameters
        ----------
        bragg_ws_list: list of (single spectrum) Bragg workspace
        clear_canvas

        Returns
        -------

        """
        # check
        assert isinstance(bragg_ws_list, list)

        # clear canvas if necessary
        if clear_canvas:
            self.ui.graphicsView_bragg.reset()

        # get unit
        curr_unit = self._currBraggXUnit
        # curr_unit = str(self.ui.comboBox_xUnit.currentText())
        # if curr_unit == 'Q':
        #     curr_unit =

        # plot all workspsaces
        for bragg_ws_name in bragg_ws_list:
            # get the last section of the workspace name: _bank%d
            postfix = bragg_ws_name.split('_')[-1]

            if postfix.startswith('bank') and 0 <= int(postfix.split('bank')[1]) <= 6:
                # belonged to a Bragg-workspace-group
                ws_group = bragg_ws_name.split('_%s' % postfix)[0] + '_group'
                bank_id = int(bragg_ws_name.split('bank')[1])
                vec_x, vec_y, vec_e = self._myController.get_bragg_data(ws_group_name=ws_group, bank_id=bank_id,
                                                                        x_unit=curr_unit)

                # construct dictionary for plotting
                plot_data_dict = dict()
                plot_data_dict[ws_group] = dict()
                plot_data_dict[ws_group][bank_id] = (vec_x, vec_y, vec_e)

                # set the bank to be checked
                self._braggBankWidgets[bank_id].setChecked(True)

                # plot
                self.ui.graphicsView_bragg.plot_banks(plot_data_dict, curr_unit)

            else:
                # plot arbitrary data
                # print '[DB] Switch to multi-GSAS mode.  Re-plot {0}'.format(bragg_ws_name)
                vec_x, vec_y, vec_e = self._myController.get_ws_data(bragg_ws_name)
                self.ui.graphicsView_bragg.plot_general_ws(bragg_ws_name, vec_x, vec_y, vec_e)

        return

    def plot_gr(self, gr_ws_name, gr_line_color, gr_line_style, gr_line_marker, gr_line_alpha, gr_line_label,
                auto=False):
        """Plot G(r) by their names (workspace as protocol)
        :param gr_ws_name:
        :param gr_line_color:
        :param gr_line_style:
        :param gr_line_marker:
        :param gr_line_alpha:
        :param gr_line_label:
        :param auto:
        :return:
        """
        # check
        assert isinstance(gr_ws_name, str), 'G(r) workspace name {0} must be a string but not a {1}.' \
                                            ''.format(gr_ws_name, type(gr_ws_name))

        # get the value
        vec_r, vec_g, vec_ge = self._myController.get_ws_data(gr_ws_name)

        # check whether the workspace is on the figure
        print '[DB...BAT] G(r) graphic has plot {0} is {1}. Keys are {2}' \
              ''.format(gr_ws_name, self.ui.graphicsView_gr.has_gr(gr_ws_name),
                        self.ui.graphicsView_gr.get_current_grs())

        if self.ui.graphicsView_gr.has_gr(gr_ws_name):
            # update G(r) value of an existing plot
            self.ui.graphicsView_gr.update_gr(gr_ws_name, vec_r, vec_g, vec_ge)
        else:
            # a new g(r) plot
            if auto:
                gr_line_color, gr_line_style, gr_line_alpha = self._pdfColorManager.get_gr_line(gr_ws_name)

            # check
            assert isinstance(gr_line_color, str), 'G(r) line color {0} must be a string but not {1}.' \
                                                   ''.format(gr_line_color ,type(gr_line_color))
            assert isinstance(gr_line_style, str), 'G(r) line style {0} must be given by str but not {1}.' \
                                                   ''.format(gr_line_style, type(gr_line_style))
            assert isinstance(gr_line_alpha, float), 'G(r) line alpha {0} must be given by float but not {1}.' \
                                                   ''.format(gr_line_alpha, type(gr_line_alpha))
            assert isinstance(gr_line_marker, str) or gr_line_marker is None,\
                'G(r) line marker {0} must be given by str or None but not {1}.' \
                ''.format(gr_line_marker, type(gr_line_marker))
            assert isinstance(gr_line_label, str), 'G(r) line label {0} must be given by list but not {1}.' \
                                                   ''.format(gr_line_label, type(gr_line_label))

            # plot G(R)
            self.ui.graphicsView_gr.plot_gr(gr_ws_name, vec_r, vec_g, vec_ge, False,
                                            gr_line_color, gr_line_style, gr_line_marker, gr_line_alpha, gr_line_label)
        # END-FOR

        return

    def plot_sq(self, sq_ws_name, sq_color, clear_prev):
        """
        Plot S(Q)
        :param sq_ws_name:
        :param sq_color: color of S(Q).  If None, then try to find it from PDF color manager
        :param clear_prev:
        :return:
        """
        # clear previous lines
        if clear_prev:
            self.ui.graphicsView_sq.reset()

        # get data
        vec_q, vec_sq, vec_se = self._myController.get_sq(sq_ws_name)

        # get the unit & do conversion if necessary
        sq_type = str(self.ui.comboBox_SofQType.currentText())
        if sq_type == 'S(Q)':
            # use the original S(Q)
            sq_unit = 'S(Q)'
            vec_y = vec_sq
        elif sq_type == 'S(Q)-1':
            # use S(Q)-1
            sq_unit = 'S(Q)-1'
            vec_y = vec_sq - 1
        elif sq_type == 'Q[S(Q)-1]':
            # use Q(S(Q)-1)
            sq_unit = 'Q[S(Q)-1]'
            vec_y = vec_q * (vec_sq - 1)
        else:
            raise RuntimeError('None of S(Q), S(Q)-1 or Q(S(Q)-1) is chosen.')

        # plot
        if clear_prev:
            reset = True
        else:
            reset = False

        # get color
        if sq_color is None:
            sq_color = self._pdfColorManager.add_sofq(sq_ws_name)

        self.ui.graphicsView_sq.plot_sq(sq_ws_name, vec_q, vec_y, vec_se, sq_unit, reset,
                                        color=sq_color)

        return

    def do_load_bragg_file(self):
        """
        Load Bragg files including GSAS, NeXus, 3-column ASCii.
        Returns
        -------
        """
        # get file
        ext = 'GSAS (*.gsa);;DAT (*.dat);;All (*.*)'

        # get default dir
        if self._currDataDir is None:
            default_dir = os.getcwd()
        else:
            default_dir = self.getDefaultDir(sub_dir='GSAS')

        bragg_file_names = QtGui.QFileDialog.getOpenFileNames(self, 'Choose Bragg File', default_dir, ext)
        if bragg_file_names is None or bragg_file_names == '' or len(bragg_file_names) == 0:
            return
        bragg_file_names = [ str(bragg_file_name) for bragg_file_name in bragg_file_names ]

        # update stored data directory
        try:
            self._currDataDir = os.path.split(os.path.abspath(bragg_file_names[0]))[0]
        except IndexError as index_err:
            err_msg = 'Unable to get absolute path of {0} due to {1}'.format(bragg_file_names, index_err)
        self.check_in_fixed_dir_structure(sub_dir='GSAS')

        # load file
        gss_ws_names = list()
        for bragg_file_name in bragg_file_names:
            gss_ws_name = self._myController.load_bragg_file(bragg_file_name)
            gss_ws_names.append(gss_ws_name)
            # split
            # FIXME - _gssGroupName may have an issie with multiple-GSS mode
            gssGroupName, banks_list, bank_angles = self._myController.split_to_single_bank(gss_ws_name)

            # add to tree
            self.ui.treeWidget_braggWSList.add_bragg_ws_group(gssGroupName, banks_list)

        # get plot mode
        if len(bragg_file_names) == 1:
            self.ui.graphicsView_bragg.set_to_single_gss(True)
            self.ui.radioButton_multiBank.setChecked(True)
            self.ui.radioButton_multiGSS.setChecked(False)
        else:
            self.ui.graphicsView_bragg.set_to_single_gss(False)
            self.ui.radioButton_multiBank.setChecked(False)
            self.ui.radioButton_multiGSS.setChecked(True)

        multi_bank_mode = self.ui.radioButton_multiBank.isChecked()

        if multi_bank_mode:
            # single-GSS/multi-bank mode
            # rename bank
            for bank_id in self._braggBankWidgets.keys():
                bank_check_box = self._braggBankWidgets[bank_id]

                if bank_id > len(bank_angles) or bank_angles[bank_id - 1] is None:
                    bank_check_box.setText('Bank %d' % bank_id)
                else:
                    bank_check_box.setText('Bank %.1f' % bank_angles[bank_id - 1])
                    # END-IF
                # END-IF-ELSE
            # END-FOR

            # clear all previous lines
            self.ui.graphicsView_bragg.reset()
        # END-IF

        # banks
        self._onCanvasGSSBankList = self.get_bragg_banks_selected()
        if len(self._onCanvasGSSBankList) == 0:
            # select bank 1 as default
            self._noEventBankWidgets = True
            self.ui.checkBox_bank1.setChecked(True)
            self._noEventBankWidgets = False
            self._onCanvasGSSBankList = self.get_bragg_banks_selected()

        # while in multiple-gss mode, no change will be made on the canvas at all

        # prepare to plot new Bragg
        # change unit
        ws_data_dict = dict()
        plot_data_dict = dict()
        for gss_ws_name in gss_ws_names:
            gss_group_name = gss_ws_name + '_group'
            for bank_id in self._onCanvasGSSBankList:
                vec_x, vec_y, vec_e = self._myController.get_bragg_data(gss_group_name, bank_id, self._currBraggXUnit)
                ws_data_dict[bank_id] = (vec_x, vec_y, vec_e)
            plot_data_dict[gss_group_name] = ws_data_dict

        # plot
        # FIXME/ISSUE/NOW - get a summary on calling to plot_banks
        self.ui.graphicsView_bragg.plot_banks(plot_data_dict, self._currBraggXUnit)

        # reset unit
        self.reset_bragg_data_range(self._currBraggXUnit)

        return

    def do_load_gr(self):
        """
        Load an ASCII file containing G(r)
        Returns:
        """
        # get default dir
        if self._currDataDir is None:
            default_dir = os.getcwd()
        else:
            default_dir = self.getDefaultDir('gofr')

        # pop out file
        file_filter = 'Data Files (*.dat);;All Files (*.*)'
        g_file_name = str(QtGui.QFileDialog.getOpenFileName(self, 'Open a G(r) file', default_dir, file_filter))

        # return if operation is cancelled
        if g_file_name is None or g_file_name == '':
            return
        else:
            # update current data directory
            self._currDataDir = os.path.split(os.path.abspath(g_file_name))[0]
            # set default data directory if in fixed file structure
            self.check_in_fixed_dir_structure('gofr')

        # read file
        status, ret_obj = self._myController.load_gr(g_file_name)
        if not status:
            err_msg = ret_obj
            print '[Error]: %s' % err_msg
            return
        else:
            gr_ws_name = ret_obj

        # plot
        gr_color, gr_style, gr_marker, gr_alpha = self._pdfColorManager.add_gofr(None, gr_ws_name, None)
        gr_label = gr_ws_name

        self.plot_gr([gr_ws_name], [gr_color], [gr_style], [gr_marker], [gr_alpha], [gr_label])

        # put the loaded G(r) workspace to tree 'workspaces'
        self.ui.treeWidget_grWsList.add_child_main_item('workspaces', gr_ws_name)

        return

    def check_in_fixed_dir_structure(self, sub_dir):
        """
        Check whether _currDataDir ends with 'GSAS', 'gofr' or 'SofQ'
        If it is, then reset the _currDataDir to its upper directory and set the in-format flag;
        Otherwise, keep as is
        """
        # make sure that the last character of currDataDir is not /
        if self._currDataDir.endswith('/') or self._currDataDir.endswith('\\'):
            # consider Linux and Windows case
            self._currDataDir = self._currDataDir[:-1]

        # split
        main_path, last_dir = os.path.split(self._currDataDir)
        if last_dir == sub_dir:
            self._inFixedDirectoryStructure = True
            self._currDataDir = main_path
        else:
            self._inFixedDirectoryStructure = False
        # END-IF-ELSE

        return 

    def getDefaultDir(self, sub_dir):
        """ Get the default data directory.
        If is in Fixed-Directory-Structure, then _currDataDir is the parent directory for all GSAS, gofr and SofQ
        and thus return the data directory with _currDataDir joined with sub_dir
        Otherwise, no operation

        :param sub_dir:
        :return: directory
        """
        # check
        assert isinstance(sub_dir, str), 'sub directory must be a string but not %s.' % type(sub_dir)

        if self._inFixedDirectoryStructure:
            default_dir = os.path.join(self._currDataDir, sub_dir)
        else:
            default_dir = self._currDataDir

        return default_dir

    @staticmethod
    def get_file_names_from_dialog(default_dir, file_filter, caption):
        """
        get the file name from a dialog
        :param default_dir:
        :param file_filter:
        :param caption
        :return:
        """
        # TODO/TEST/NOW - Find out what this method can get!!!
        # check input
        assert isinstance(default_dir, str), 'Default directory {0} must be a string but not a {1}.' \
                                             ''.format(default_dir, type(default_dir))
        assert isinstance(file_filter, str), 'File filter {0} must be a string but not a {1}.' \
                                               ''.format(file_filter, type(file_filter))

        # generate a dialog to get the file name to save G(r)
        export_dialog = QtGui.QFileDialog()
        export_dialog.setWindowTitle(caption)
        export_dialog.setDirectory(default_dir)
        export_dialog.setAcceptMode(QtGui.QFileDialog.AcceptSave)
        export_dialog.setNameFilter(file_filter)

        # quit if it is not accepted
        if export_dialog.exec_() != QtGui.QFileDialog.Accepted:
            return None
        elif len(export_dialog.selectedFiles()) == 0:
            return None

        # get the file name from dialog
        file_name_list = list()
        for file_name in export_dialog.selectedFiles():
            file_name_list.append(str(file_name))

        return file_name_list

    def do_load_sq(self):
        """
        Load S(Q) from file
        Returns
        -------

        """
        # get default dir
        if self._currDataDir is None:
            default_dir = os.getcwd()
        else:
            default_dir = self.getDefaultDir(sub_dir='SofQ')

        # get the file
        ext = 'DAT (*.dat);;All (*.*)'
        sq_file_names = QtGui.QFileDialog.getOpenFileNames(self, 'Choose S(Q) File', default_dir, ext)
        if sq_file_names is None or sq_file_names == '':
            return
        else:
            # update current data directory
            self._currDataDir = os.path.split(os.path.abspath(sq_file_names[0]))[0]
            self.check_in_fixed_dir_structure('SofQ')

        # load S(q)
        for sq_file_name in sq_file_names:
            sq_file_name = str(sq_file_name)
            sq_ws_name, q_min, q_max = self._myController.load_sq(sq_file_name)
            # add to color management
            sq_color = self._pdfColorManager.add_sofq(sq_ws_name)

            # set to the tree and combo box
            self.ui.treeWidget_grWsList.add_sq(sq_ws_name)
            self.ui.comboBox_SofQ.addItem(sq_ws_name)
            self.ui.comboBox_SofQ.setCurrentIndex(self.ui.comboBox_SofQ.count()-1)

            # set the UI widgets
            self.ui.doubleSpinBoxQmin.setValue(q_min)
            self.ui.doubleSpinBoxQmax.setValue(q_max)

            # plot S(Q)
            sq_name = self._myController.get_current_sq_name()

            self.plot_sq(sq_name, sq_color=sq_color, clear_prev=False)

            # calculate and calculate G(R)
            self.do_generate_gr()

        return

    def do_edit_sq(self):
        """
        Launch a dialog box to edit S(Q) by shift and scaling.
        :return:
        """
        # create dialog instance if it does not exist
        if self._editSqDialog is None:
            self._editSqDialog = addie.edit_sq_dialog.EditSofQDialog(self)

        # get current S(Q) list and add to dialog
        sq_name_list = list()
        num_sq = self.ui.comboBox_SofQ.count()
        for isq in range(num_sq):
            sq_name = str(self.ui.comboBox_SofQ.itemText(isq))
            sq_name_list.append(sq_name)
        # END-FOR

        self._editSqDialog.add_sq_by_name(sq_name_list)

        # show
        self._editSqDialog.show()

        return

    def do_generate_sq(self):
        """
        generate S(Q) from G(r) by PDFFourierTransform
        :return:
        """
        # TODO/ISSUE/NOW - Need to implement!
        raise NotImplementedError('Dialog box for generating S(Q) has not been implemented yet.')
        # get setup
        min_r = float(self.ui.doubleSpinBoxRmin.value())
        max_r = float(self.ui.doubleSpinBoxRmax.value())
        min_q = self.ui.doubleSpinBoxQmin.value()
        max_q = self.ui.doubleSpinBoxQmax.value()

        # launch the dialog box
        if self._generateSofQDialog is None:
            self._generateSofQDialog = blabla

        self._generateSofQDialog.set_r_range(min_r, max_r)
        self._generateSofQDialog.set_q_range(min_q, max_q)

        self._generateSofQDialog.show()

        return

    def signal_generate_sq(self, arg_dict):
        """
        signal handling method to generate S(q)
        Note:  https://github.com/neutrons/FastGR/issues/91
        :return:
        """
        # check input
        assert isinstance(arg_dict, dict), 'Input arguments {0} must be given in a dictionary but not a {1}.' \
                                           ''.format(arg_dict, type(arg_dict))

        # determine the selected G(r)
        gr_ws_name_list = self.ui.treeWidget_grWsList.get_workspaces()
        # print '[DB] Selected G(r) workspaces have {0} items.'.format(len(gr_ws_name_list))
        # for gr in gr_ws_name_list:
        #     print '[DB] G(r) {0} of type {1}.'.format(gr, type(gr))

        # check the arguments
        for required_param in ['Qmin', 'Qmax', 'Rmin', 'Rmax', 'DeltaR']:
            if required_param not in arg_dict.keys():
                raise RuntimeError('Not sufficient parameter (missing {0}) to generate S(Q) from G(r).'
                                   ''.format(required_param))

        # TODO/FIXME/FUTURE - Call Mantid algorithm to calculate S(Q)
        raise NotImplementedError('Implement this in future.')

        return

    def do_save_gr(self):
        """
        Save the selected the G(r) from menu to ASCII file
        :return:
        """
        # TEST/ISSUE/NOW - Look at https://github.com/neutrons/FastGR/issues/28

        # read the selected item from the tree
        gr_name_list = self.ui.treeWidget_grWsList.get_selected_items_of_level(2, excluded_parent='SofQ',
                                                                               return_item_text=True)
        if len(gr_name_list) != 1:
            err_msg = 'Error! Only 1 workspace of G(r) that can be selected.  So far %d is selected.' \
                'They are %s.' % (len(gr_name_list), str(gr_name_list))
            QtGui.QMessageBox.warning(self, 'Error', err_msg)
            return
        else:
            gr_ws_name = gr_name_list[0]

        # pop-up a dialog for the file to save
        default_dir = os.getcwd()
        caption = 'Save G(r)'

        # TEST/ISSUE/NOW - Refactor the following part out to be a standard widget
        file_filter_str = 'XYE (*.xye);;CSV XYE (*.csv);;PDFgui (*.gr);;RMCProfile (*.dat)'
        gr_file_name = self.get_file_names_from_dialog(default_dir, file_filter_str, caption)[0]

        # check the file extension and use the file extension to determine G(r) file type
        file_name, file_ext = os.path.splitext(gr_file_name)
        if file_ext.lower().startswith('.xye'):
            gr_file_type = 'xye'
        elif file_ext.lower().startswith('.csv'):
            gr_file_type = 'csv'
        elif file_ext.lower().startswith('.gr'):
            gr_file_type = 'gr'
        elif file_ext.lower().startswith('.dat'):
            gr_file_type = 'rmcprofile'
        else:
            # unsupported
            raise RuntimeError('G(r) file with extension {0} is not supported.'.format(file_ext))

        # save!
        self._myController.save_ascii(gr_ws_name, gr_file_name, gr_file_type)

        return

    def do_save_sq(self):
        """Save the selected the G(r) from menu to ASCII file
        :return:
        """
        # TEST/ISSUE/NOW - Test!

        # read the selected item from the tree... return if nothing is selected
        sq_name_list = self.ui.treeWidget_grWsList.get_selected_items_of_level(2, excluded_parent='GofR',
                                                                               return_item_text=True)
        if len(sq_name_list) == 0:
            return

        # loop the SofQ name to save
        file_filter = 'XYE (*.xye);;CSV XYE (*.csv);;SofQ (*.sq)'

        for sq_name in sq_name_list:
            # get the output file name first
            out_file_name = str(QtGui.QFileDialog.getSaveFileName(self, 
                'Input File Name to Save S(Q) {0}'.format(sq_name), self._currWorkDir, file_filter))
            if out_file_name is None or len(out_file_name) == 0:
                # skip if the user cancel the operation on this S(Q)
                continue

            # get the directory, file name and extension
            self._currWorkDir = os.path.dirname(out_file_name)
            file_name, file_ext = os.path.splitext(out_file_name)
            if file_ext.lower().startswith('.xye'):
                sq_file_type = 'xye'
            elif file_ext.lower().startswith('.csv'):
                sq_file_type = 'csv'
            elif file_ext.lower().startswith('.sq'):
                sq_file_type = 'dat'
            elif file_ext.lower().startswith('.dat'):
                sq_file_type = 'dat'
            elif len(file_ext.strip()) == 0:
                raise RuntimeError('There is no extension of file {0}. Unable to determine file type.'
                                   ''.format(out_file_name))
            else:
                raise RuntimeError('File type {0} cannot be recognized.'.format(file_ext))

            # save file
            self._myController.save_ascii(sq_name, out_file_name, sq_file_type)
        # END-FOR

        return

    def do_show_sq_bound(self):
        """
        Show or hide the left and right boundary of the S(Q)
        :return:
        """
        q_left = self.ui.doubleSpinBoxQmin.value()
        q_right = self.ui.doubleSpinBoxQmax.value()
        self.ui.graphicsView_sq.toggle_boundary(q_left, q_right)

        return

    def get_bragg_banks_selected(self):
        """
        Find out the banks of bragg-tab that are selected.
        Returns:

        """
        bank_id_list = list()
        for bank_id in self._braggBankWidgets.keys():
            # access the checkbox
            bank_checkbox = self._braggBankWidgets[bank_id]
            # append
            if bank_checkbox.isChecked():
                bank_id_list.append(bank_id)
        # END-FOR

        return bank_id_list

    def edit_sq(self, sq_name, scale_factor, shift):
        """Edit S(Q) in workspace with scale_factor * Y[i] + shift
        :param sq_name:
        :param scale_factor:
        :param shift:
        :return:
        """
        # convert
        sq_name = str(sq_name)

        # check inputs
        assert isinstance(sq_name, str), 'S(Q) workspace name {0} must be a string but not a {1}.' \
                                         ''.format(sq_name, type(sq_name))
        assert isinstance(scale_factor, float), 'Scale factor {0} must be a float but not a {1}.' \
                                                ''.format(scale_factor, type(scale_factor))
        assert isinstance(shift, float), 'Shift {0} must be a float but not a {1}.'.format(shift, type(shift))

        # call the controller
        edit_sq_name = sq_name + '_Edit'
        self._myController.edit_matrix_workspace(sq_name, scale_factor, shift, edit_sq_name)
        # add new S(Q)
        self._pdfColorManager.add_sofq(edit_sq_name)

        color, marker = self.ui.graphicsView_sq.get_plot_info(sq_name)
        print '[DB...BAT] Original SofQ {0} has color {0} marker {1}'.format(color, marker)

        # re-plot
        vec_q, vec_s, vec_e = self._myController.get_sq(edit_sq_name)
        self.ui.graphicsView_sq.plot_sq(edit_sq_name, vec_q, vec_s, vec_e, sq_y_label=sq_name + ' In Edit',
                                        reset_color_mark=False,
                                        color=color, marker=marker)

        # calculate G(r) too
        self.generate_gr([edit_sq_name])

        return

    def evt_change_gss_mode(self):
        """ switch between multi-gss/single-bank mode and singl-gss/multiple-bank mode
        :return:
        """
        # check the mode (multiple bank or multiple GSS)
        single_gss_mode = self.ui.radioButton_multiBank.isChecked()
        assert single_gss_mode != self.ui.radioButton_multiGSS.isChecked(),\
            'Multi bank and multi GSS cannot be checked simultaneously.'

        # get the banks that are selected
        to_plot_bank_list = self.get_bragg_banks_selected()
        on_canvas_ws_list = self.ui.graphicsView_bragg.get_workspaces()
        # return with doing anything if the canvas is empty, i.e., no bank is selected
        if len(to_plot_bank_list) == 0:
            return
        # return if there is no workspace that is plotted on canvas now
        if len(on_canvas_ws_list) == 0:
            return

        # set to single GSS
        self.ui.graphicsView_bragg.set_to_single_gss(single_gss_mode)

        # process the plot with various situation
        if single_gss_mode:
            # switch to single GSAS mode from multiple GSAS mode.
            #  select the arbitrary gsas file to
            assert len(to_plot_bank_list) == 1, 'From multi-GSS-single-Bank mode, only 1 bank can be selected.'

            # skip if there is one and only one workspace
            if len(on_canvas_ws_list) == 1:
                return
            else:
                status, ws_name_list = self.ui.treeWidget_braggWSList.get_current_main_nodes()
                if not status:
                    raise RuntimeError(str(ws_name_list))
                else:
                    plot_ws_name = ws_name_list[0]

            # plot
            plot_ws_name = plot_ws_name.split('_group')[0]
            bragg_bank_ws = '%s_bank%d' % (plot_ws_name, to_plot_bank_list[0])
            self.plot_bragg(bragg_ws_list=[bragg_bank_ws], clear_canvas=True)

        else:
            # multiple GSAS mode. as currently there is one GSAS file that is plot, then the first bank
            # that is plotted will be kept on the canvas
            # assumption: switched from single-bank mode

            # skip if there is one and only 1 bank that is selected
            # if len(to_plot_bank_list) == 1:
            # TEST/ISSUE/NOW - Need to re-plot with correct color!
            #     return
            # else:
            # choose first bank
            bank_on_canvas = to_plot_bank_list[0]

            # disable all the banks except the one to plot. Notice the mutex must be on
            self._noEventBankWidgets = True
            for bank_id in self._braggBankWidgets.keys():
                if bank_id != bank_on_canvas:
                    self._braggBankWidgets[bank_id].setChecked(False)
            self._noEventBankWidgets = False

            # plot
            plot_ws_name = on_canvas_ws_list[0]
            bragg_bank_ws = '%s_bank%d' % (plot_ws_name, bank_on_canvas)
            self.plot_bragg(bragg_ws_list=[bragg_bank_ws], clear_canvas=True)

            # set
            self._onCanvasGSSBankList = [bank_on_canvas]

        # END-IF-ELSE

        return

    def evt_plot_bragg_bank(self):
        """
        Find out which bank will be plot

        cases to trigger this event:
        1. select more banks
        2. deselect some banks

        Returns
        -------

        """
        # check mutex for not responding the event
        if self._noEventBankWidgets:
            return
        # check
        #assert self._gssGroupName is not None, 'GSAS group name cannot be None'

        # get mode for plotting
        plot_multi_gss = self.ui.radioButton_multiGSS.isChecked()

        # find the change of the banks
        current_bank_set = set(self.get_bragg_banks_selected())
        prev_bank_set = set(self._onCanvasGSSBankList)

        if plot_multi_gss:
            # multi-gss/single-bank mode
            # get the banks to remove
            rm_bank_list = self._onCanvasGSSBankList[:]

            # deselect all the old banks and thus turn on the mutex
            self._noEventBankWidgets = True
            # turn off the
            self.set_bragg_banks_selected(self._onCanvasGSSBankList, False)
            # turn off mutex
            self._noEventBankWidgets = False

            # set banks to add
            new_bank_list = list(current_bank_set - prev_bank_set)
            assert len(new_bank_list) <= 1, 'Impossible to have more than 1 banks selected in multi-GSS mode.'

            # set the current on canvas
            self._onCanvasGSSBankList = new_bank_list

            # print '[DB...BAT] Multi-GSS-Mode: New ... ', new_bank_list, '; Remove... ', rm_bank_list

        else:
            # single-gss/multi-bank mode
            # determine the banks to add
            new_bank_list = list(current_bank_set - prev_bank_set)
            rm_bank_list = list(prev_bank_set - current_bank_set)

            # print '[DB...BAT] Single-GSS-Mode: New ... ', new_bank_list, '; Remove... ', rm_bank_list

            # set the current on-canvas
            self._onCanvasGSSBankList = list(current_bank_set)

        # END-IF-ELSE

        # get GSS data (group)
        if plot_multi_gss:
            # multiple GSAS file/single bank mode: get GSAS group from tree
            gss_group_list = self.ui.treeWidget_braggWSList.get_main_nodes()
            gss_group_list.remove('workspaces')

        else:
            # single GSAS file mode
            status, ret_obj = self.ui.treeWidget_braggWSList.get_current_main_nodes()
            if status:
                gss_group = ret_obj[0]
            else:
                raise RuntimeError('Unable to get current selected main node(s) due to {0}.'.format(ret_obj))
            gss_group_list = [gss_group]

        # remove banks from plot
        for gss_group_name in gss_group_list:
            self.ui.graphicsView_bragg.remove_gss_banks(gss_group_name, rm_bank_list)

        # get new bank data
        plot_data_dict = dict()
        for ws_group in gss_group_list:
            ws_data_dict = dict()
            for bank_id in new_bank_list:
                vec_x, vec_y, vec_e = self._myController.get_bragg_data(ws_group, bank_id, self._currBraggXUnit)
                ws_data_dict[bank_id] = (vec_x, vec_y, vec_e)
            # END-FOR
            plot_data_dict[ws_group] = ws_data_dict
        # END-FOR

        if plot_multi_gss:
            self.ui.graphicsView_bragg.set_to_single_gss(False)
        else:
            self.ui.graphicsView_bragg.set_to_single_gss(True)
            status, ws_name_list = self.ui.treeWidget_braggWSList.get_current_main_nodes()
            plot_data_dict = { ws_name_list[0] : plot_data_dict[ws_name_list[0]]  } 

        # plot new
        self.ui.graphicsView_bragg.plot_banks(plot_data_dict, self._currBraggXUnit)

        # reset
        self.reset_bragg_data_range(self._currBraggXUnit)

        # rescale
        self.do_rescale_bragg()

        return

    def evt_switch_bragg_unit(self):
        """
        Unit of Bragg plot is changed.
        Requirements:
        1. clear the canvas
        2. plot all the banks in the new units
        3. reset the limit
        Returns
        -------

        """
        # get current unit and check whether re-plot all banks is not a choice
        x_unit = str(self.ui.comboBox_xUnit.currentText())
        # convert Q to MomentumTransfer by Mantid standard
        if x_unit == 'Q':
            x_unit = 'MomentumTransfer'

        if x_unit == self._currBraggXUnit:
            # return if no change. then this cannot happen
            raise RuntimeError('New unit %s is same as original unit %s.' % (x_unit, self._currBraggXUnit))
        else:
            self._currBraggXUnit = x_unit

        # reset canvas
        self.ui.graphicsView_bragg.reset()

        # get bank to plot
        bank_list = self.get_bragg_banks_selected()

        # get data sets
        #  = self.ui.treeWidget_braggWSList.get_main_nodes()
        ws_group_list = self.ui.treeWidget_braggWSList.get_selected_items_of_level(
            target_item_level=1, excluded_parent=None, return_item_text=True)
        if 'workspace' in ws_group_list:
            ws_group_list.remove('workspaces')
        assert len(ws_group_list) > 0, 'At least 1 GSS file must be selected.'

        # check
        assert len(bank_list) == 1 or len(ws_group_list) == 1, 'Must be either single bank (%d now) or ' \
               'single GSS (%d now).' % (len(bank_list),
                                         len(ws_group_list))

        # get data and plot
        plot_data_dict = dict()
        for ws_group in ws_group_list:
            ws_data_dict = dict()
            for bank_id in bank_list:
                vec_x, vec_y, vec_e = self._myController.get_bragg_data(ws_group, bank_id, self._currBraggXUnit)
                ws_data_dict[bank_id] = (vec_x, vec_y, vec_e)
            # END-FOR
            plot_data_dict[ws_group] = ws_data_dict
        # END-FOR

        # plot
        self.ui.graphicsView_bragg.plot_banks(plot_data_dict, self._currBraggXUnit)

        # reset unit
        self.reset_bragg_data_range(x_unit)

        return

    def reset_bragg_data_range(self, x_unit):
        """

        Parameters
        ----------
        x_unit

        Returns
        -------

        """
        self.ui.graphicsView_bragg.set_unit(x_unit)

        if x_unit == 'TOF':
            self.ui.graphicsView_bragg.setXYLimit(xmin=0, xmax=20000, ymin=None, ymax=None)
        elif x_unit == 'MomentumTransfer':
            self.ui.graphicsView_bragg.setXYLimit(xmin=0, xmax=20, ymin=None, ymax=None)
        elif x_unit == 'dSpacing':
            self.ui.graphicsView_bragg.setXYLimit(xmin=0, xmax=7, ymin=None, ymax=None)
        else:
            raise RuntimeError('Unit %s unknown' % x_unit)

        return

    def evt_change_sq_type(self):
        """ Event handling to plot S(Q)
        Returns
        -------

        """
        # get the current S(Q) names
        curr_sq_list = self.ui.graphicsView_sq.get_shown_sq_names()
        if len(curr_sq_list) == 0:
            return

        # reset the canvas
        self.ui.graphicsView_sq.reset()

        # re-plot
        for sq_name in curr_sq_list:
            # plot S(Q)
            self.plot_sq(sq_name, sq_color=None, clear_prev=False)

        return

    def evt_qmax_changed(self):
        """
        Handle if the user change the value of Qmax of S(Q) including
        1. moving the right boundary in S(q) figure
        Returns:

        """
        q_min = self.ui.doubleSpinBoxQmin.value()
        q_max = self.ui.doubleSpinBoxQmax.value()

        if q_min < q_max and self.ui.graphicsView_sq.is_boundary_shown():
            self.ui.graphicsView_sq.move_right_indicator(q_max, relative=False)

        return

    def evt_qmin_changed(self):
        """

        Returns:

        """
        q_min = self.ui.doubleSpinBoxQmin.value()
        q_max = self.ui.doubleSpinBoxQmax.value()

        if q_min < q_max and self.ui.graphicsView_sq.is_boundary_shown():
            self.ui.graphicsView_sq.move_left_indicator(q_min, relative=False)

        return

    def evt_quit(self):
        """
        Quit the application
        Returns:

        """
        self.close()

    def get_default_data_dir(self):
        """
        Get default data directory
        Returns:
        """
        return self._currDataDir

    def get_workflow(self):
        """
        Return the reference to the main workflow controller
        Returns: workflow controller

        """
        return self._myController

    def process_workspace_change(self, new_ws_list):
        """
        Process (including
        1. add workspace name to tree list and etc) when detecting that
        there is some change to any workspace

        Parameters
        ----------
        new_ws_list :: list of new workspaces' names

        Returns
        -------

        """
        # check input
        assert isinstance(new_ws_list, list), 'Input workspace list must be a list of string' \
               'but not %s.' % str(type(new_ws_list))

        # print 'current tab = ', self.ui.tabWidget_2.currentIndex(), self.ui.tabWidget_2.currentWidget(),
        # print self.ui.tabWidget_2.currentWidget().objectName()
        # print 'current workspaces: ', self._myController.get_current_workspaces()

        # add to tree
        if len(new_ws_list) > 0:
            if self.ui.tabWidget_2.currentWidget().objectName() == 'tab_gR':
                # a new G(r) or S(q)
                for new_ws in new_ws_list:
                    ws_unit = self._myController.get_ws_unit(new_ws)
                    if ws_unit != 'MomentumTransfer':
                        is_gr = True
                    else:
                        # case for SofQ
                        is_gr = False
                        # add to combo box
                        self.ui.comboBox_SofQ.addItem(new_ws)
                        self.ui.treeWidget_grWsList.add_sq(new_ws)
                        # plot generated S(Q)
                        self.plot_sq(sq_ws_name=new_ws, sq_color=None, clear_prev=False)
                    # END-IF
                    self.ui.treeWidget_grWsList.add_arb_gr(new_ws, is_gr)

            elif self.ui.tabWidget_2.currentWidget().objectName() == 'tab_bragg':
                # new Bragg pattern
                for new_ws in new_ws_list:
                    self.ui.treeWidget_braggWSList.add_arb_gr(new_ws)
            # END-IF-ELSE

        return

    def remove_gr_from_plot(self, gr_name):
        """Remove a GofR line from GofR canvas
        :param gr_name: supposed to the G(r) name that is same as workspace name and plot key on canvas as well
        :return:
        """
        # check
        assert isinstance(gr_name, str), 'G(r) plot key {0} must be a string but not a {1}' \
                                         ''.format(gr_name, type(gr_name))

        # remove
        self.ui.graphicsView_gr.remove_gr(plot_key=gr_name)

        return

    def remove_gss_from_plot(self, gss_group_name, gss_bank_ws_name_list):
        """Remove a GSAS group from canvas if they exits
        :param gss_group_name: name of the GSS node, i.e., GSS workspace group's name
        :param gss_bank_ws_name_list: list of names of GSS single banks' workspace name
        :return:
        """
        # check
        assert isinstance(gss_group_name, str), 'GSS group workspace name must be a string but not %s.' \
               '' % str(type(gss_group_name))
        assert isinstance(gss_bank_ws_name_list, list), 'GSAS-single-bank workspace names {0} must be given by ' \
                                                        'list but not {1}.'.format(gss_bank_ws_name_list,
                                                                                   type(gss_bank_ws_name_list))
        if len(gss_bank_ws_name_list) == 0:
            raise RuntimeError('GSAS-single-bank workspace name list is empty!')

        # get bank IDs
        bank_ids = list()
        for gss_bank_ws in gss_bank_ws_name_list:
            bank_id = int(gss_bank_ws.split('_bank')[-1])
            bank_ids.append(bank_id)

        # remove
        self.ui.graphicsView_bragg.remove_gss_banks(gss_group_name, bank_ids)

        # check if there is no such bank's plot on figure, make sure the checkbox is unselected
        # turn on the mutex lock
        self._noEventBankWidgets = True

        for bank_id in range(1, 7):
            has_plot_on_canvas = len(self.ui.graphicsView_bragg.get_ws_name_on_canvas(bank_id)) > 0
            self._braggBankWidgets[bank_id].setChecked(has_plot_on_canvas)

        # turn off the mutex lock
        self._noEventBankWidgets = False


        return

    def remove_sq_from_plot(self, sq_name):
        """
        Remove an SofQ line from SofQ canvas
        Args:
            sq_name: supposed to be the S(Q) name which is same as workspace name and plot key of canvas

        Returns:

        """
        # check
        assert isinstance(sq_name, str)

        # remove
        if self.ui.graphicsView_sq.is_on_canvas(sq_name):
            self.ui.graphicsView_sq.remove_sq(sq_ws_name=sq_name)

        return

    def set_bragg_banks_selected(self, bank_id_list, status):
        """
        set the status of selected bank IDs
        Note: mutex on Bragg Bank selection widgets is not turned on!!!
        Parameters
        ----------
        bank_id_list
        status

        Returns
        -------

        """
        # check inputs
        assert isinstance(bank_id_list, list), 'Bank IDs {0} must be given in a list but not a {1}.' \
                                               ''.format(bank_id_list, type(bank_id_list))
        assert isinstance(status, bool), 'Selection status {0} must be a boolean but not a {1}.' \
                                         ''.format(status, type(status))

        # set
        for bank_id in bank_id_list:
            self._braggBankWidgets[bank_id].setChecked(status)

        return

    def set_bragg_ws_to_plot(self, gss_group_name):
        """
        Set a Bragg workspace group to plot.  If the Bragg-tab is in
        (1) single-GSS mode, then switch to plot this gss_group
        (2) multiple-GSS mode, then add this group to current canvas
        Parameters
        ----------
        gss_group_name

        Returns
        -------

        """
        # check
        assert isinstance(gss_group_name, str), 'GSS workspace group name is expected to be a string, but not' \
               ' %s.' % str(type(gss_group_name))

        # rule out the unsupported situation
        assert gss_group_name.endswith('_group'), 'GSAS workspace group\' name must be ends with _group, ' \
               'but not as %s.' % gss_group_name
        root_ws_name = gss_group_name.split('_group')[0]

        # process
        if self.ui.radioButton_multiBank.isChecked():
            # single-GSS/multi-bank mode
            # reset canvas
            self.ui.graphicsView_bragg.reset()

            # get the banks to plot
            selected_banks = self.get_bragg_banks_selected()

            bragg_ws_list = ['%s_bank%d' % (root_ws_name, bank_id) for bank_id in selected_banks]
            self.plot_bragg(bragg_ws_list=bragg_ws_list, clear_canvas=False)

        else:
            # multiple-GSS/single-bank mode
            # canvas is not be reset

            # get the bank to plot
            selected_banks = self.get_bragg_banks_selected()
            assert len(selected_banks) <= 1, 'At most 1 bank can be plot in multiple-GSS mode.'

            # form the workspace
            bragg_ws = '%s_bank%d' % (root_ws_name, selected_banks[0])

            self.plot_bragg(bragg_ws_list=[bragg_ws], clear_canvas=False)

        # END-IF-ELSE

        return

    def set_ipython_script(self, script):
        """
        Write a command (python script) to ipython console
        Parameters
        ----------
        script

        Returns
        -------

        """
        # check
        assert isinstance(script, str)

        #
        if len(script) == 0:
            # ignore
            return
        else:
            # write to the console
            self.ui.dockWidget_ipython.iPythonWidget.write_command(script)

        return

    def update_sq_boundary(self, boundary_index, new_position):
        """Update the S(Q) range at the main app inputs
        :param boundary_index:
        :param new_position:
        :return:
        """
        # check
        assert isinstance(boundary_index, int), 'Boundary index {0} must be an integer but not {1}.' \
                                                ''.format(boundary_index, type(boundary_index))
        assert isinstance(new_position, float), 'New position {0} must be a float but not {1}.' \
                                                ''.format(new_position, type(new_position))

        # set value
        if boundary_index == 1:
            # left boundary
            self.ui.doubleSpinBoxQmin.setValue(new_position)
        elif boundary_index == 2:
            # right boundary
            self.ui.doubleSpinBoxQmax.setValue(new_position)
        else:
            # exception
            raise RuntimeError('Boundary index %f in method update_sq_boundary() is not '
                               'supported.' % new_position)

        return

    def add_edited_sofq(self, sofq_name, edited_sq_name, shift_value, scale_factor_value):
        """add an edited S(Q) to cached dictionary
        :param sofq_name:
        :param edited_sq_name:
        :param shift_value:
        :param scale_factor_value:
        :return:
        """
        # check
        assert isinstance(sofq_name, str), 'SofQ workspace name {0} must be a string but not a {1}.' \
                                           ''.format(sofq_name, type(sofq_name))
        assert isinstance(edited_sq_name, str), 'Edited S(Q) workspace name {0} must be a string but not a {1}.' \
                                                ''.format(edited_sq_name, type(edited_sq_name))

        # add the entry for the original S(Q) if not done yet
        if sofq_name not in self._editedSofQDict:
            self._editedSofQDict[sofq_name] = dict()

        # add entry
        self._editedSofQDict[sofq_name][shift_value, scale_factor_value] = edited_sq_name

        # add the line and color manager
        self._pdfColorManager.add_sofq(edited_sq_name)

        return

    def has_edit_sofq(self, raw_sofq_name, shift_value, scale_factor_value):
        """ check whether an edited S(Q) has been cached already
        :param raw_sofq_name:
        :param shift_value:
        :param scale_factor_value:
        :return:
        """
        # check
        assert isinstance(raw_sofq_name, str)

        if raw_sofq_name not in self._editedSofQDict:
            return False

        return (shift_value, scale_factor_value) in self._editedSofQDict[raw_sofq_name]

    # menu
    def action_preview_ascii_clicked(self):
        o_gui = Step3GuiHandler(parent = self)
        o_gui.browse_file()

    def action_load_configuration_clicked(self):
        o_import_config = ImportConfiguration(parent = self)
        o_import_config.run()

    def action_save_configuration_clicked(self):
        o_export_config = ExportConfiguration(parent = self)
        o_export_config.run()

    def action_undo_clicked(self):
        o_undo = UndoHandler(parent=self)
        o_undo.undo_table()

    def action_redo_clicked(self):
        o_undo = UndoHandler(parent=self)
        o_undo.redo_table()

    def help_about_clicked(self):
        _about = AboutDialog(parent=self)
        _about.display()

    def advanced_option_clicked(self):
        _advanced = AdvancedWindowLauncher(parent = self)

    def menu_ipts_file_transfer_clicked(self):
        _o_ipts = IptsFileTransferDialog(parent=self)
        _o_ipts.show()

    def main_tab_widget_changed(self, tab_selected):
        if tab_selected == 0:
            o_gui = Step1GuiHandler(parent = self)
            self.check_step1_gui()
        if tab_selected == 1:
            _o_gui = Step2GuiHandler(parent = self)
            _o_gui.check_gui()

    def window_job_monitor_clicked(self):
        job_handler = JobStatusHandler(parent=self)

    def help_button_clicked(self, button_name='autonom'):
        help_button_activator(parent=self, button_name=button_name)

    # job utility
    def launch_job_manager(self, job_name='', script_to_run=None, thread_index=-1):
        job_handler = JobStatusHandler(parent=self, job_name=job_name,
                                       script_to_run = script_to_run,
                                       thread_index = thread_index)
        job_handler.start()

    def kill_job(self, row=-1):
        job_row = self.job_list[row]
        parent = psutil.Process(job_row['pid'])
        for child in parent.children(recursive=True):
            child.kill()
#	    child.wait()
        parent.kill()

        table_widget = self.job_monitor_interface.ui.tableWidget
        table_widget.removeCellWidget(row, 2)
        _item = QtGui.QTableWidgetItem('Killed')
        table_widget.setItem(row, 2, _item)
        job_row['status'] = "killed"
        job_row['pid'] = None
        self.job_list[row] = job_row

    def start_refresh_text_thread(self):
        _run_thread = self.logbook_thread
        _run_thread.setup(parent = self)
        _run_thread.update_text.connect(self.update_logbook)
        _run_thread.start()	

    def update_logbook(self, text):
        if self.job_monitor_interface == None:
            self.logbook_thread.stop()
        else:
            _logbook_handler = LogbookHandler(parent=self)

    # tab1
    def select_current_folder_clicked(self):
        o_gui = Step1GuiHandler(parent = self)
        o_gui.select_working_folder()
        self.check_step1_gui()

    def diamond_edited(self):
        self.check_step1_gui()

    def diamond_background_edited(self):
        self.check_step1_gui()

    def vanadium_edited(self):
        self.check_step1_gui()

    def vanadium_background_edited(self):
        self.check_step1_gui()

    def sample_background_edited(self):
        self.check_step1_gui()

    def create_new_autonom_folder_button_clicked(self, status):
        o_gui_handler = Step1GuiHandler(parent = self)
        o_gui_handler.new_autonom_group_box(status = status)

    def output_folder_radio_buttons(self):
        o_gui_handler = Step1GuiHandler(parent=self)
        o_gui_handler.manual_output_folder_button_handler()
        o_gui_handler.check_go_button()

    def manual_output_folder_field_edited(self):
        self.check_step1_gui()

    def manual_output_folder_button_clicked(self):
        o_gui = Step1GuiHandler(parent = self)
        o_gui.select_manual_output_folder()
        self.check_step1_gui()

    def check_step1_gui(self):
        '''check the status of the step1 GUI in order to enable or not the GO BUTTON at the bottom'''
        o_gui_handler = Step1GuiHandler(parent=self)
        o_gui_handler.check_go_button()

    def run_autonom(self):
        """Will first create the output folder, then create the exp.ini file"""
        _run_autonom = RunStep1(parent = self)
        _run_autonom.create_folder()
        print(os.getcwd())
        _run_autonom.create_exp_ini_file()

    def help_button_clicked_autonom(self):
        self.help_button_clicked(button_name = 'autonom')

    def create_exp_ini_clicked(self):
        _run_autonom = RunStep1(parent = self, run_autonom=False)
        _run_autonom.create_folder()
        _run_autonom.create_exp_ini_file()

    # tab2
    def resize_table_post_processing_tab(self, height, width):
        pass

    def move_to_folder_clicked(self):
        o_load_table = loadTableIntermediateStepInterface(parent = self)
        o_load_table.show()

    def move_to_folder_step2(self):
        if not self.load_intermediate_step_ok:
            return

        o_gui = Step2GuiHandler(parent = self)
        o_gui.move_to_folder()
        self.populate_table_clicked()

    def populate_table_clicked(self):

        self.ui.table.blockSignals(True)

        _pop_table = PopulateMasterTable(parent = self)
        _pop_table.run()
        _error_reported = _pop_table.error_reported

        if _error_reported:
            self.ui.table.blockSignals(False)
            return

        _pop_back_wdg = PopulateBackgroundWidgets(parent = self)
        _pop_back_wdg.run()
        self.name_search_clicked()

        _o_gui = Step2GuiHandler(parent = self)
        _o_gui.check_gui()

        o_undo = UndoHandler(parent = self)
        o_undo.save_table(first_save=True)

        self.ui.table.blockSignals(False)

    def import_table_clicked(self):
        self.ui.table.blockSignals(True)

        _o_table = TableHandler(parent = self)
        _o_table._import()
        self.name_search_clicked()

        o_undo = UndoHandler(parent = self)
        o_undo.save_table(first_save=True)

        self.ui.table.blockSignals(False)

    def export_table_clicked(self):
        _o_table = TableHandler(parent = self)
        _o_table._export()

    def table_select_state_changed(self, state, row):
        _o_table_handler = TableHandler(parent=self)
        _o_table_handler.check_selection_status(state, row)

        _o_gui = Step2GuiHandler(parent = self)
        _o_gui.check_gui()
        _o_gui.define_new_ndabs_output_file_name()
        _o_gui.define_new_sum_scans_output_file_name()

    def name_search_clicked(self):
        o_table = TableHandler(parent = self)
        o_table.name_search()

    def clear_name_search_clicked(self):
        o_table = TableHandler(parent = self)
        self.ui.name_search.setText('')
        o_table.name_search()

    def check_step2_gui(self, row, column):
        _o_gui = Step2GuiHandler(parent = self)
        _o_gui.check_gui()

        _o_gui.step2_background_flag()
        _o_gui.step2_update_background_dropdown()

        if column == 1:
            o_pop = PopulateBackgroundWidgets(parent=self)
            o_pop.refresh_contain()

        o_undo = UndoHandler(parent = self)
        o_undo.save_table()

    # PDF

    def check_q_range(self):
        _o_gui = Step2GuiHandler(parent = self)
        _o_gui.check_gui()

    def hidrogen_clicked(self):
        o_gui = Step2GuiHandler(parent = self)
        o_gui.hidrogen_clicked()

    def no_hidrogen_clicked(self):
        o_gui = Step2GuiHandler(parent = self)
        o_gui.no_hidrogen_clicked()

    def yes_background_clicked(self):
        o_gui = Step2GuiHandler(parent = self)
        o_gui.yes_background_clicked()

    def no_background_clicked(self):
        o_gui = Step2GuiHandler(parent = self)
        o_gui.no_background_clicked()

    def background_combobox_changed(self, index):
        o_gui = Step2GuiHandler(parent = self)
        o_gui.background_index_changed(row_index = index)

    def reset_q_range(self):
        o_gui = Step2GuiHandler(parent = self)
        o_gui.reset_q_range()

    def run_ndabs_clicked(self):
        o_create_sample_files = CreateSampleFiles(parent = self)
        o_create_sample_files.run()

        list_sample_files = o_create_sample_files.list_sample_files

        o_create_ndsum_file = CreateNdsumFile(parent = self)
        o_create_ndsum_file.run()

        o_run_ndsum = RunNDabs(parent = self, list_sample_files = list_sample_files)
        o_run_ndsum.run()

    def check_fourier_filter_widgets(self):
        o_gui = Step2GuiHandler(parent = self)
        o_gui.check_gui()

    def check_plazcek_widgets(self):
        o_gui = Step2GuiHandler(parent = self)
        o_gui.check_gui()

    def table_right_click(self, position):
        _o_table = TableHandler(parent = self)
        _o_table.right_click(position = position)

    def run_sum_scans_clicked(self):
        o_run_sum_scans = RunSumScans(parent = self)
        o_run_sum_scans.run()

    def output_file_name_changed(self):
        o_gui = Step2GuiHandler(parent = self)
        o_gui.check_gui()

    def pdf_qmax_line_edit_changed(self):
        o_gui = Step2GuiHandler(parent = self)
        o_gui.check_gui()	

    def sum_scans_output_file_name_changed(self):
        o_gui = Step2GuiHandler(parent = self)
        o_gui.check_gui()	

    def help_button_clicked_ndabs(self):
        self.help_button_clicked(button_name = 'ndabs')

    def help_button_clicked_scans(self):
        self.help_button_clicked(button_name = 'scans')

    # Rietveld

    def mantid_browse_calibration_clicked(self):
        o_mantid_gui = BrowseFileFolderHandler(parent = self)
        o_mantid_gui.browse_file(type = 'calibration')

    def mantid_browse_characterization_clicked(self):
        o_mantid_gui = BrowseFileFolderHandler(parent = self)
        o_mantid_gui.browse_file(type = 'characterization')

    def mantid_output_directory_clicked(self):
        o_mantid_gui = BrowseFileFolderHandler(parent = self)
        o_mantid_gui.browse_folder()

    def mantid_run_reduction(self):
        o_mantid_run = GlobalMantidReduction(parent = self)
        o_mantid_run.run()

    def check_mantid_gui(self):
        o_gui = Step2GuiHandler(parent = self)
        o_gui.check_gui()

    def help_button_clicked_mantid(self):
        self.help_button_clicked(button_name = 'mantid')

    # Mantid

    def make_calibration_clicked(self):
        _make = MakeCalibrationLauncher(parent=self)

    # New tab with advanced table

    # master table
    def personalization_table_clicked(self):
        o_master_table_tree = TableTreeHandler(parent=self)
        _table_config = TableConfig(parent=self)
        current_config = _table_config.get_current_config()
#        o_master_table = MasterTableHandler(parent=self)
#        o_master_table.update_tree_dict_and_tree(config_to_load=current_config)
        self.update_tree_dict_and_tree(config_to_load=current_config)

    def closeEvent(self, c):
        if self.advanced_window_ui:
            self.advanced_window_ui.closeEvent(c)
        if self.make_calibration_ui:
            self.make_calibration_ui.closeEvent(c)
        if self.table_tree_ui:
            self.table_tree_ui.closeEvent(c)













    # This part takes care of the master table and will have to be moved into its own file !!!
    # FIXME
    def resizing_h1(self, index_column, old_size, new_size):
#        print("resizing h1 column {}".format(index_column))

        self.block_table_ui()

        h2_children = self.get_h2_children_from_h1(h1=index_column)
        # print("h2 children: {}".format(h2_children))

        last_h2_visible = self.get_last_h2_visible(list_h2=h2_children)
        # print("last h2 visible: {}".format(last_h2_visible))

        list_h3 = self.get_h3_children_from_h2(h2=last_h2_visible)
        # print("h3 children: {}".format(list_h3))

        last_h3_visible = self.get_last_h3_visible(list_h3=list_h3)
        # print("Last h3 visible: {}".format(last_h3_visible))

        size_diff = new_size - old_size

        # add this size_diff to last_h2 and last_h3
        last_h3_visible_size = self.get_size_column(h3=last_h3_visible)
        if (last_h3_visible_size < self.minimum_col_width) and \
                (new_size < old_size):
            self.set_size_column(h1=index_column, width=old_size)
        else:
            last_h2_visible_size = self.get_size_column(h2=last_h2_visible)
            self.set_size_column(h2=last_h2_visible, width=last_h2_visible_size+size_diff)
            self.set_size_column(h3=last_h3_visible, width=last_h3_visible_size+size_diff)

        self.block_table_ui(unblock_all=True)
        # print("")


    def load_this_config(self, key='', resize=False):
        if key == '':
            return

        if key == 'FULL_RESET':
            config_to_load = self.reset_config_dict['table']
        else:
            config_to_load = self.config_dict[key]['table']

        h1_dict = config_to_load['h1']
        h2_dict = config_to_load['h2']
        h3_dict = config_to_load['h3']

        # print("config to load")
        # pprint.pprint(config_to_load)
        # print("load this config")
        # pprint.pprint(self.tree_dict)
        # print()
        # pprint.pprint(self.tree_dict.keys())

        self.block_table_ui()

        for _col in h1_dict:
            _visible = h1_dict[_col]['visible']
            _width = h1_dict[_col]['width']
            self.set_size_and_visibility_column(h1=_col, width=_width, visibility=_visible, resize=resize)

        for _col in h2_dict:
            _visible = h2_dict[_col]['visible']
            _width = h2_dict[_col]['width']
            self.set_size_and_visibility_column(h2=_col, width=_width, visibility=_visible, resize=resize)

        for _col in h3_dict:
            _visible = h3_dict[_col]['visible']
            _width = h3_dict[_col]['width']
            self.set_size_and_visibility_column(h3=_col, width=_width, visibility=_visible, resize=resize)

        self.update_tree_dict_and_tree(config_to_load)
        # self.update_full_tree_status()

        self.block_table_ui(unblock_all=True)

    def update_tree_dict_and_tree(self, config_to_load={}):
        '''This method will update the tree_dict dictionary as well as the state of the tree'''

        if self.table_tree_ui is None:
            return

        if config_to_load == {}:
            return

        def from_boolean_to_ui_status(visible):
            if visible:
                return QtCore.Qt.Checked
            else:
                return QtCore.Qt.Unchecked

        def change_state_tree_widgets(list_tree_ui, list_h_columns):
            for _ui, _key in zip(list_tree_ui, list_h_columns):
                if _ui is None:
                    continue
                else:
                    _config = list_h_columns[_key]
                    _visibility = _config['visible']
                    _state = from_boolean_to_ui_status(_visibility)
                    _ui.setCheckState(0, _state)

        self.ui.treeWidget.blockSignals(True)

        # print("config_to_load")
        # pprint.pprint(config_to_load)

        tree_ui = self.tree_ui

        # working with h1
        list_h1_columns = config_to_load['h1']
        list_h1_tree_ui = tree_ui['h1']
        change_state_tree_widgets(list_h1_tree_ui, list_h1_columns)

        # working with h2
        list_h2_columns = config_to_load['h2']
        list_h2_tree_ui = tree_ui['h2']
        change_state_tree_widgets(list_h2_tree_ui, list_h2_columns)

        # working with h3
        list_h3_columns = config_to_load['h3']
        list_h3_tree_ui = tree_ui['h3']
        change_state_tree_widgets(list_h3_tree_ui, list_h3_columns)

        self.ui.treeWidget.blockSignals(False)

    def h3_table_right_click(self, position):
        o_h3_table = H3TableHandler(parent=self)
        o_h3_table.right_click()

    def scroll_h1_table(self, value):
        self.ui.h2_table.horizontalScrollBar().setValue(value)
        self.ui.h3_table.horizontalScrollBar().setValue(value)

    def scroll_h2_table(self, value):
        self.ui.h1_table.horizontalScrollBar().setValue(value)
        self.ui.h3_table.horizontalScrollBar().setValue(value)

    def scroll_h3_table(self, value):
        self.ui.h1_table.horizontalScrollBar().setValue(value)
        self.ui.h2_table.horizontalScrollBar().setValue(value)

    def block_table_ui(self, block_all=True,
                       unblock_all=False,
                       block_h1=False,
                       block_h2=False,
                       block_h3=False):

        if block_all:
            block_h1 = True
            block_h2 = True
            block_h3 = True

        if unblock_all:
            block_h1 = False
            block_h2 = False
            block_h3 = False

        if block_h1:
            self.h1_header_table.sectionResized.disconnect(self.resizing_h1)
        else:
            self.h1_header_table.sectionResized.connect(self.resizing_h1)

        if block_h2:
            self.h2_header_table.sectionResized.disconnect(self.resizing_h2)
        else:
            self.h2_header_table.sectionResized.connect(self.resizing_h2)

        if block_h3:
            self.h3_header_table.sectionResized.disconnect(self.resizing_h3)
        else:
            self.h3_header_table.sectionResized.connect(self.resizing_h3)

    def resizing_h1(self, index_column, old_size, new_size):
        # print("resizing h1 column {}".format(index_column))

        self.block_table_ui()

        h2_children = self.get_h2_children_from_h1(h1=index_column)
        # print("h2 children: {}".format(h2_children))

        last_h2_visible = self.get_last_h2_visible(list_h2=h2_children)
        # print("last h2 visible: {}".format(last_h2_visible))

        list_h3 = self.get_h3_children_from_h2(h2=last_h2_visible)
        # print("h3 children: {}".format(list_h3))

        last_h3_visible = self.get_last_h3_visible(list_h3=list_h3)
        # print("Last h3 visible: {}".format(last_h3_visible))

        size_diff = new_size - old_size

        # add this size_diff to last_h2 and last_h3
        last_h3_visible_size = self.get_size_column(h3=last_h3_visible)
        if (last_h3_visible_size < self.minimum_col_width) and \
                (new_size < old_size):
            self.set_size_column(h1=index_column, width=old_size)
        else:
            last_h2_visible_size = self.get_size_column(h2=last_h2_visible)
            self.set_size_column(h2=last_h2_visible, width=last_h2_visible_size + size_diff)
            self.set_size_column(h3=last_h3_visible, width=last_h3_visible_size + size_diff)

        self.block_table_ui(unblock_all=True)
        # print("")

    def resizing_h2(self, index_column, old_size, new_size):
        # print("resizing h2 column {}".format(index_column))

        self.block_table_ui()

        h1_parent = self.get_h1_parent_from_h2(h2=index_column)
        # print("h1_parent: {}".format(h1_parent))

        h3_children = self.get_h3_children_from_h2(h2=index_column)
        # print("h3 children: {}".format(h3_children))

        last_h3_visible = self.get_last_h3_visible(list_h3=h3_children)
        # print("last h3 visible is {}".format(last_h3_visible))

        size_diff = new_size - old_size

        last_h3_visible_size = self.get_size_column(h3=last_h3_visible)
        if (last_h3_visible_size < self.minimum_col_width) and \
                (new_size < old_size):
            self.set_size_column(h2=index_column, width=old_size)
        else:
            # add this size_diff to parent and last h3
            parent_size = self.get_size_column(h1=h1_parent)
            self.set_size_column(h1=h1_parent, width=parent_size + size_diff)
            self.set_size_column(h3=last_h3_visible, width=last_h3_visible_size + size_diff)

        self.block_table_ui(unblock_all=True)

    def resizing_h1_using_all_visible_h2(self, h1=None):
        '''automatically resize the h1 using all its h2 visible '''
        h2_children = self.get_h2_children_from_h1(h1=h1)
        list_visible_h2 = self.get_all_h2_visible(list_h2=h2_children)

        if list_visible_h2 is None:
            return

        full_size_h2 = 0
        for _h2 in list_visible_h2:
            full_size_h2 += self.get_size_column(h2=_h2)

        self.ui.h1_table.setColumnWidth(h1, full_size_h2)

    def resizing_h3(self, index_column, old_size, new_size):
        # print("resizing h3 column {}".format(index_column))

        self.block_table_ui()

        [h1_parent, h2_parent] = self.get_h1_h2_parent_from_h3(h3=index_column)
        # print("h1_parent, h2_parent: {},{}".format(h1_parent, h2_parent))

        size_diff = new_size - old_size

        # get h2 and h1 size and resize them
        h1_parent_size = self.get_size_column(h1=h1_parent)
        self.set_size_column(h1=h1_parent, width=h1_parent_size + size_diff)
        h2_parent_size = self.get_size_column(h2=h2_parent)
        self.set_size_column(h2=h2_parent, width=h2_parent_size + size_diff)

        self.block_table_ui(unblock_all=True)

    def resizing_h2_using_all_visible_h3(self, h2=None):
        '''automatically resizing the h2 using all its h3 visible'''
        h3_children = self.get_h3_children_from_h2(h2=h2)
        list_visible_h3 = self.get_all_h3_visible(list_h3=h3_children)

        if list_visible_h3 is None:
            return

        full_size_h3 = 0
        for _h3 in list_visible_h3:
            full_size_h3 += self.get_size_column(h3=_h3)

        self.ui.h2_table.setColumnWidth(h2, full_size_h3)

    # Utilites

    def is_h_visible(self, h1=None, h2=None, h3=None):
        table_ui = self.get_table_ui(h1=h1, h2=h2, h3=h3)
        master_h = self.get_master_h(h1=h1, h2=h2, h3=h3)
        return not table_ui.isColumnHidden(master_h)

    def get_table_ui(self, h1=None, h2=None, h3=None):
        '''h1, h2 or h3 are column indexes'''
        if not h1 is None:
            table_ui = self.ui.h1_table
        elif not h2 is None:
            table_ui = self.ui.h2_table
        elif not h3 is None:
            table_ui = self.ui.h3_table
        else:
            table_ui = None
        return table_ui

    def get_master_h(self, h1=None, h2=None, h3=None):
        '''return the only defined column index from h1, h2 or h3 table'''
        if not h1 is None:
            return h1
        elif not h2 is None:
            return h2
        elif not h3 is None:
            return h3
        else:
            return None

    def get_size_column(self, h1=None, h2=None, h3=None):
        table_ui = self.get_table_ui(h1=h1, h2=h2, h3=h3)
        h = self.get_master_h(h1=h1, h2=h2, h3=h3)
        return table_ui.columnWidth(h)

    def set_size_column(self, h1=None, h2=None, h3=None, width=None):
        if width is None:
            return

        table_ui = self.get_table_ui(h1=h1, h2=h2, h3=h3)
        h = self.get_master_h(h1=h1, h2=h2, h3=h3)
        table_ui.setColumnWidth(h, width)

    def set_visibility_column(self, h1=None, h2=None, h3=None, visibility=True):
        table_ui = self.get_table_ui(h1=h1, h2=h2, h3=h3)
        h = self.get_master_h(h1=h1, h2=h2, h3=h3)
        table_ui.setColumnHidden(h, not visibility)

    def set_size_and_visibility_column(self, h1=None, h2=None, h3=None, width=None, visibility=True, resize=False):
        if resize:
            self.set_size_column(h1=h1, h2=h2, h3=h3, width=width)
        self.set_visibility_column(h1=h1, h2=h2, h3=h3, visibility=visibility)

    def get_h2_children_from_h1(self, h1=-1):
        if h1 == -1:
            return None

        table_columns_links = self.table_columns_links
        list_h2_values = table_columns_links['h2']

        return list_h2_values[h1]

    def get_all_h2_visible(self, list_h2=[]):
        '''return the list of all the visible h2 from the list of h2 given'''
        if list_h2 == []:
            return None

        list_h2_visible = [_h2 for _h2 in list_h2 if not self.ui.h2_table.isColumnHidden(_h2)]
        return list_h2_visible

    def get_last_h2_visible(self, list_h2=[]):
        if list_h2 == []:
            return None

        for _h2 in list_h2[::-1]:
            if self.ui.h2_table.isColumnHidden(_h2):
                continue
            else:
                return _h2

        return None

    def get_all_h3_visible(self, list_h3=[]):
        '''return the list of all the visible h3 from the list of h3 given'''
        if list_h3 == []:
            return None

        list_h3_visible = [_h3 for _h3 in list_h3 if not self.ui.h3_table.isColumnHidden(_h3)]
        return list_h3_visible

    def get_last_h3_visible(self, list_h3=[]):
        if list_h3 == []:
            return None

        for _h3 in list_h3[::-1]:
            if self.ui.h3_table.isColumnHidden(_h3):
                continue
            else:
                return _h3

        return None

    def get_h3_children_from_h2(self, h2=-1):
        if h2 == -1:
            return None

        table_columns_links = self.table_columns_links
        list_h3_values = table_columns_links['h3']
        list_h2_values = table_columns_links['h2']

        index_h2 = -1
        index_h1 = 0
        for h2_values in list_h2_values:
            if h2 in h2_values:
                index_h2 = h2_values.index(h2)
                break
            index_h1 += 1

        if index_h2 == -1:
            return []

        return list_h3_values[index_h1][index_h2]

    def get_h1_parent_from_h2(self, h2=-1):
        if h2 == -1:
            return None

        table_columns_links = self.table_columns_links
        list_h2_values = table_columns_links['h2']

        h1_parent_index = 0
        for h2_values in list_h2_values:
            if h2 in h2_values:
                return h1_parent_index
            h1_parent_index += 1

        return None

    def get_h1_h2_parent_from_h3(self, h3=-1):
        if h3 == -1:
            return [None, None]

        table_columns_links = self.table_columns_links
        list_h3_values = table_columns_links['h3']

        h1_parent_index = 0
        h2_parent_index = 0

        for h3_values in list_h3_values:
            for local_h3 in h3_values:
                if h3 in local_h3:
                    return [h1_parent_index, h2_parent_index]
                h2_parent_index += 1
            h1_parent_index += 1

        return [None, None]

    def resizing_table(self, tree_dict={}, block_ui=True):
        '''updating the size of the columns using visibility of the various elements of the tree'''
        if tree_dict == {}:
            return

        if block_ui:
            self.block_table_ui()

        # if user disabled or enabled at the h1 level, nothing to do as all the columns will be automatically
        # resized the right way
        h1 = tree_dict['h1']
        h2 = tree_dict['h2']
        h3 = tree_dict['h3']
        if not h1 == []:
            pass

        # if user clicked at the h2 level
        elif not h2 == []:

            h2 = h2[0]

            h1_parent = self.get_h1_parent_from_h2(h2=h2)
            is_h1_parent_visible = self.is_h_visible(h1=h1_parent)

            if is_h1_parent_visible:
                # resize h2 using all visible h3
                self.resizing_h2_using_all_visible_h3(h2=h2)

                # if h1 parent is visible, re-sized h1 parent using all visible h2
                self.resizing_h1_using_all_visible_h2(h1=h1_parent)

            else:
                # if h1 parent is not visible, done !
                pass

        # if user clicked at the h3 level
        elif not h3 == []:

            h3 = h3[0]

            [h1_parent, h2_parent] = self.get_h1_h2_parent_from_h3(h3=h3)
            is_h2_parent_visible = self.is_h_visible(h2=h2_parent)

            if is_h2_parent_visible:
                # if we have more h3 siblings visible
                # - we need to resize h2_parent using visible h3 siblings
                # - we need to resize h1_parent using all visible h2
                self.resizing_h2_using_all_visible_h3(h2=h2_parent)
                self.resizing_h1_using_all_visible_h2(h1=h1_parent)

            else:
                # if there are no more h3 siblings then
                #      if h1_parent visible -> resize h1_parent using all h2 visible
                #      if h1_parent not visible -> Done !
                h2 = h2_parent

                h1_parent = self.get_h1_parent_from_h2(h2=h2)
                is_h1_parent_visible = self.is_h_visible(h1=h1_parent)

                if is_h1_parent_visible:
                    # if h1 parent is visible, resized h1 parent using all visible h2
                    self.resizing_h1_using_all_visible_h2(h1=h1_parent)

                else:
                    # if h1 parent is not visible, done !
                    pass

        if block_ui:
            self.block_table_ui(unblock_all=True)

    def init_headers(self):
        td = self.tree_dict

        table_headers = {'h1': [], 'h2': [], 'h3': []}
        for _key_h1 in td.keys():
            table_headers['h1'].append(td[_key_h1]['name'])
            if td[_key_h1]['children']:
                for _key_h2 in td[_key_h1]['children'].keys():
                    table_headers['h2'].append(td[_key_h1]['children'][_key_h2]['name'])
                    if td[_key_h1]['children'][_key_h2]['children']:
                        for _key_h3 in td[_key_h1]['children'][_key_h2]['children'].keys():
                            table_headers['h3'].append(td[_key_h1]['children'][_key_h2]['children'][_key_h3]['name'])
                    else:
                        table_headers['h3'].append('')
            else:
                table_headers['h2'].append('')
                table_headers['h3'].append('')

        self.table_headers = table_headers

    def init_table_col_width(self, table_width=[], table_ui=None):
        for _col in np.arange(table_ui.columnCount()):
            table_ui.setColumnWidth(_col, table_width[_col])

    def init_table_header(self, table_ui=None, list_items=None):
        table_ui.setColumnCount(len(list_items))
        for _index, _text in enumerate(list_items):
            item = QTableWidgetItem(_text)
            table_ui.setHorizontalHeaderItem(_index, item)

    def init_table_dimensions(self):
        td = self.tree_dict

        table_width = {'h1': [], 'h2': [], 'h3': []}

        # check all the h1 headers
        for _key_h1 in td.keys():

            # if h1 header has children
            if td[_key_h1]['children']:

                absolute_nbr_h3_for_this_h1 = 0

                # loop through list of h2 header for this h1 header
                for _key_h2 in td[_key_h1]['children'].keys():

                    # if h2 has children, just count how many children
                    if td[_key_h1]['children'][_key_h2]['children']:
                        nbr_h3 = len(td[_key_h1]['children'][_key_h2]['children'])

                        for _ in np.arange(nbr_h3):
                            table_width['h3'].append(self.default_width)

                        ## h2 header will be as wide as the number of h3 children
                        table_width['h2'].append(nbr_h3 * self.default_width)

                        ## h1 header will be += the number of h3 children
                        absolute_nbr_h3_for_this_h1 += nbr_h3

                    # if h2 has no children
                    else:

                        ## h2 header is 1 wide
                        table_width['h2'].append(self.default_width)
                        table_width['h3'].append(self.default_width)

                        ## h2 header will be += 1
                        absolute_nbr_h3_for_this_h1 += 1

                table_width['h1'].append(absolute_nbr_h3_for_this_h1 * self.default_width)

            # if h1 has no children
            else:
                # h1, h2 and h3 are 1 wide
                table_width['h1'].append(self.default_width)
                table_width['h2'].append(self.default_width)
                table_width['h3'].append(self.default_width)

        self.table_width = table_width

    def init_tables(self):

        # set h1, h2 and h3 headers
        self.init_headers()
        self.init_table_header(table_ui=self.ui.h1_table, list_items=self.table_headers['h1'])
        self.init_table_header(table_ui=self.ui.h2_table, list_items=self.table_headers['h2'])
        self.init_table_header(table_ui=self.ui.h3_table, list_items=self.table_headers['h3'])

        # set h1, h2 and h3 width
        self.init_table_dimensions()
        self.init_table_col_width(table_width=self.table_width['h1'], table_ui=self.ui.h1_table)
        self.init_table_col_width(table_width=self.table_width['h2'], table_ui=self.ui.h2_table)
        self.init_table_col_width(table_width=self.table_width['h3'], table_ui=self.ui.h3_table)

        self.h1_header_table = self.ui.h1_table.horizontalHeader()
        self.h2_header_table = self.ui.h2_table.horizontalHeader()
        self.h3_header_table = self.ui.h3_table.horizontalHeader()

        self.make_tree_of_column_references()

    def init_widgets(self):
        pass

    def init_tree(self):
        # fill the self.ui.treeWidget
        # self.addItems(self.ui.treeWidget.invisibleRootItem())
        self.addItems(self.ui.treeWidget.invisibleRootItem())
        self.ui.treeWidget.itemChanged.connect(self.tree_item_changed)

    def get_item_name(self, item):
        td = self.tree_dict

        for _key_h1 in td.keys():

            if item == td[_key_h1]['ui']:
                return _key_h1

            if td[_key_h1]['children']:

                for _key_h2 in td[_key_h1]['children'].keys():

                    if item == td[_key_h1]['children'][_key_h2]['ui']:
                        return _key_h2

                    if td[_key_h1]['children'][_key_h2]['children']:

                        for _key_h3 in td[_key_h1]['children'][_key_h2]['children'].keys():

                            if item == td[_key_h1]['children'][_key_h2]['children'][_key_h3]['ui']:
                                return _key_h3

        return None

    def tree_item_changed(self, item, _):
        """this will change the way the big table will look like by hidding or showing columns"""
        # print("name of item is: {}".format(self.get_item_name(item)))

        self.h1_header_table.blockSignals(True)
        self.h2_header_table.blockSignals(True)
        self.h3_header_table.blockSignals(True)

        h_columns_affected = self.get_h_columns_from_item_name(item_name=self.get_item_name(item))

        # import pprint
        # pprint.pprint(h_columns_affected)

        self.change_state_tree(list_ui=h_columns_affected['list_tree_ui'],
                               list_parent_ui=h_columns_affected['list_parent_ui'],
                               state=item.checkState(0))

        self.update_table_columns_visibility()
        self.resizing_table(tree_dict=h_columns_affected, block_ui=False)

        self.h1_header_table.blockSignals(False)
        self.h2_header_table.blockSignals(False)
        self.h3_header_table.blockSignals(False)

    def make_all_columns_visible(self):
        """Make all columns of all table visible"""
        self.make_table_columns_visible(table_ui=self.ui.h1_table)
        self.make_table_columns_visible(table_ui=self.ui.h2_table)
        self.make_table_columns_visible(table_ui=self.ui.h3_table)

    def make_table_columns_visible(self, table_ui=None):
        """Make all columns of the given table ui visible"""
        nbr_col_h1 = table_ui.columnCount()
        for _col in np.arange(nbr_col_h1):
            table_ui.setColumnHidden(_col, False)

    # def get_state_from_boolean(self, visibility=None):
    #     if visibility is None:
    #         return False
    #
    #     if visibility is True:
    #         return QtCore.Qt.Checked
    #     else:
    #         return QtCore.Qt.Unchecked

    def update_table_columns_visibility(self):
        # will update the table by hiding or not the columns

        def set_column_visibility(column=-1, table_ui=None, visible=0):
            table_ui.setColumnHidden(column, not visible)

        def get_boolean_state(key=None):
            status = key['state']
            if status == QtCore.Qt.Checked:
                return True
            else:
                return False

        h2_counter = 0
        h3_counter = 0

        td = self.tree_dict
        for h1_counter, _key_h1 in enumerate(td.keys()):

            _h1_boolean_status = get_boolean_state(td[_key_h1])

            set_column_visibility(column=h1_counter,
                                  table_ui=self.ui.h1_table,
                                  visible=_h1_boolean_status)

            if td[_key_h1]['children']:

                for _key_h2 in td[_key_h1]['children'].keys():

                    _h2_boolean_status = get_boolean_state(td[_key_h1]['children'][_key_h2])
                    set_column_visibility(column=h2_counter,
                                          table_ui=self.ui.h2_table,
                                          visible=_h2_boolean_status)

                    if td[_key_h1]['children'][_key_h2]['children']:

                        for _key_h3 in td[_key_h1]['children'][_key_h2]['children'].keys():
                            _h3_boolean_status = get_boolean_state(
                                td[_key_h1]['children'][_key_h2]['children'][_key_h3])
                            set_column_visibility(column=h3_counter,
                                                  table_ui=self.ui.h3_table,
                                                  visible=_h3_boolean_status)
                            h3_counter += 1

                    else:

                        set_column_visibility(column=h3_counter,
                                              table_ui=self.ui.h3_table,
                                              visible=_h2_boolean_status)
                        h3_counter += 1

                    h2_counter += 1

            else:

                # h2 and h3 should have the same status as h1
                set_column_visibility(column=h2_counter,
                                      table_ui=self.ui.h2_table,
                                      visible=_h1_boolean_status)
                set_column_visibility(column=h3_counter,
                                      table_ui=self.ui.h3_table,
                                      visible=_h1_boolean_status)

                h2_counter += 1
                h3_counter += 1

    def change_state_tree(self, list_ui=[], list_parent_ui=[], state=0):
        """
        Will transfer the state of the parent to the children. We also need to make sure that if all the children
        are disabled, the parent gets disable as well.

        :param list_ui:
        :param list_parent_ui:
        :param state:
        :return:
        """

        self.ui.treeWidget.blockSignals(True)

        for _ui in list_ui:
            _ui.setCheckState(0, state)

        # if the leaf is enabled, we need to make sure all the parents are enabled as well.
        if state == QtCore.Qt.Checked:
            for _ui in list_parent_ui:
                _ui.setCheckState(0, state)

        self.update_full_tree_status()
        self.ui.treeWidget.blockSignals(False)

    def update_full_tree_status(self):
        """this will update the tree_dict dictionary with the status of all the leaves"""
        td = self.tree_dict

        # clean tree
        # if all h3 of an h2 are disabled, h2 should be disabled
        # if all h2 of a h1 are disabled, h1 should be disabled
        for _key_h1 in td.keys():

            if td[_key_h1]['children']:

                all_h2_disabled = True

                for _key_h2 in td[_key_h1]['children'].keys():

                    if td[_key_h1]['children'][_key_h2]['children']:

                        all_h3_disabled = True
                        for _key_h3 in td[_key_h1]['children'][_key_h2]['children'].keys():

                            if td[_key_h1]['children'][_key_h2]['children'][_key_h3]['ui'].checkState(0):
                                all_h3_disabled = False
                                all_h2_disabled = False
                                break

                        if all_h3_disabled:
                            # we need to make sure the h2 is disabled as well
                            td[_key_h1]['children'][_key_h2]['ui'].setCheckState(0, QtCore.Qt.Unchecked)

                    else:

                        if td[_key_h1]['children'][_key_h2]['ui'].checkState(0):
                            all_h2_disabled = False

                if all_h2_disabled:
                    # we need to make sure the h1 is disabled as well then
                    td[_key_h1]['ui'].setCheckState(0, QtCore.Qt.Unchecked)

        # record full tree state
        for _key_h1 in td.keys():

            td[_key_h1]['state'] = td[_key_h1]['ui'].checkState(0)

            if td[_key_h1]['children']:

                for _key_h2 in td[_key_h1]['children'].keys():

                    td[_key_h1]['children'][_key_h2]['state'] = td[_key_h1]['children'][_key_h2]['ui'].checkState(0)

                    if td[_key_h1]['children'][_key_h2]['children']:

                        for _key_h3 in td[_key_h1]['children'][_key_h2]['children'].keys():
                            td[_key_h1]['children'][_key_h2]['children'][_key_h3]['state'] = \
                                td[_key_h1]['children'][_key_h2]['children'][_key_h3]['ui'].checkState(0)

        self.tree_dict = td

    def make_tree_of_column_references(self):
        """
        table_columns_links = {'h1': [], 'h2': [], 'h3': []}

        h1 = [0, 1, 2]  # number of h1 columns
        h2 = [[0], [1,2,3], [4]] link of h2 columns with h1
        h3 = [ [[0]], [[1,2], [3,4], [5]], [[6,7,8]] ]

        :return:
        None
        """

        h1 = []
        h2 = []
        h3 = []

        h2_index = 0
        h3_index = 0

        td = self.tree_dict
        for h1_index, _key_h1 in enumerate(td.keys()):

            h1.append(h1_index)

            if td[_key_h1]['children']:

                _h2 = []
                _h3_h2 = []
                for _key_h2 in td[_key_h1]['children']:

                    if td[_key_h1]['children'][_key_h2]['children']:

                        _h3_h3 = []
                        for _key_h3 in td[_key_h1]['children'][_key_h2]['children']:
                            _h3_h3.append(h3_index)
                            h3_index += 1

                        _h3_h2.append(_h3_h3)

                    else:
                        # h2 does not have any h3 children
                        _h3_h2.append([h3_index])
                        h3_index += 1

                    _h2.append(h2_index)
                    h2_index += 1

                h3.append(_h3_h2)
                h2.append(_h2)

            else:
                # h1 does not have any h2 children

                h2.append([h2_index])
                h3.append([[h3_index]])
                h2_index += 1
                h3_index += 1

        self.table_columns_links = {'h1': h1,
                                    'h2': h2,
                                    'h3': h3,
                                    }

    def get_h_columns_from_item_name(self, item_name=None):
        # h_columns_affected = {'h1': [],
        #                       'h2': [],
        #                       'h3': [],
        #                       'list_tree_ui': [],
        #                       'list_parent_ui': []}

        if item_name == None:
            return

        h1_columns = []
        h2_columns = []
        h3_columns = []
        list_tree_ui = []
        list_parent_ui = []

        h1_global_counter = 0
        h2_global_counter = 0
        h3_global_counter = 0

        td = self.tree_dict
        for h1_global_counter, _key_h1 in enumerate(td.keys()):

            if item_name == _key_h1:
                # get all h2 and h3 of this h1

                if td[_key_h1]['children']:

                    for _key_h2 in td[_key_h1]['children']:

                        if td[_key_h1]['children'][_key_h2]['children']:

                            list_tree_ui.append(td[_key_h1]['children'][_key_h2]['ui'])
                            for _key_h3 in td[_key_h1]['children'][_key_h2]['children'].keys():
                                h3_columns.append(h3_global_counter)
                                list_tree_ui.append(td[_key_h1]['children'][_key_h2]['children'][_key_h3]['ui'])
                                h3_global_counter += 1

                        else:

                            h2_columns.append(h2_global_counter)
                            list_tree_ui.append(td[_key_h1]['children'][_key_h2]['ui'])
                            h3_columns.append(h3_global_counter)

                            h2_global_counter += 1
                            h3_global_counter += 1

                    return {'h1': [h1_global_counter],
                            'h2': h2_columns,
                            'h3': h3_columns,
                            'list_tree_ui': list_tree_ui,
                            'list_parent_ui': list_parent_ui}

                else:

                    list_tree_ui.append(td[_key_h1]['ui'])
                    return {'h1': [h1_global_counter],
                            'h2': [h2_global_counter],
                            'h3': [h3_global_counter],
                            'list_tree_ui': list_tree_ui,
                            'list_parent_ui': list_parent_ui}

            else:
                # start looking into the h2 layer if it has children

                if td[_key_h1]['children']:

                    for _key_h2 in td[_key_h1]['children'].keys():

                        if item_name == _key_h2:
                            # get all h3 for this h2 and we are done

                            if td[_key_h1]['children'][_key_h2]['children']:
                                # if key_h2 has children

                                # list all h3 leaves for this h2
                                for _key_h3 in td[_key_h1]['children'][_key_h2]['children'].keys():
                                    h3_columns.append(h3_global_counter)
                                    list_tree_ui.append(td[_key_h1]['children'][_key_h2]['children'][_key_h3]['ui'])
                                    h3_global_counter += 1

                            else:
                                h3_columns = [h3_global_counter]

                            list_tree_ui.append(td[_key_h1]['children'][_key_h2]['ui'])
                            list_parent_ui.append(td[_key_h1]['ui'])
                            return {'h1': [],
                                    'h2': [h2_global_counter],
                                    'h3': h3_columns,
                                    'list_tree_ui': list_tree_ui,
                                    'list_parent_ui': list_parent_ui}

                        else:
                            # we did not find the item name yet

                            # start looking into all the h2 children (if any)
                            if td[_key_h1]['children'][_key_h2]['children']:

                                # loop through all the h3 and look for item_name. If found
                                # we are done
                                for _key_h3 in td[_key_h1]['children'][_key_h2]['children'].keys():

                                    if item_name == _key_h3:
                                        # we found the item name at the h3 layer,
                                        # no leaf below, so we are done

                                        list_parent_ui.append(td[_key_h1]['ui'])
                                        list_parent_ui.append(td[_key_h1]['children'][_key_h2]['ui'])
                                        return {'h1': [],
                                                'h2': [],
                                                'h3': [h3_global_counter],
                                                'list_tree_ui': list_tree_ui,
                                                'list_parent_ui': list_parent_ui}

                                    else:

                                        h3_global_counter += 1

                                h2_global_counter += 1

                            else:
                                # no children, we just keep going to the next h2 (and h3)

                                h2_global_counter += 1
                                h3_global_counter += 1

                else:
                    # no children and item_name has not been found yet, so
                    # just keep going and move on to the next h1
                    h2_global_counter += 1
                    h3_global_counter += 1

        return {'h1': h1_columns,
                'h2': h2_columns,
                'h3': h3_columns,
                'list_tree_ui': list_tree_ui,
                'list_parent_ui': list_parent_ui}

    def addItems(self, parent):
        td = self.tree_dict
        absolute_parent = parent

        tree_ui = {'h1': [],
                   'h2': [],
                   'h3': []}

        h1_index = 0
        h2_index = 0
        h3_index = 0

        def set_h_indexes(location, h1=None, h2=None, h3=None):
            location['h_index']['h1'] = h1
            location['h_index']['h2'] = h2
            location['h_index']['h3'] = h3

        for _key_h1 in td.keys():

            # if there are children, we need to use addParent
            if td[_key_h1]['children']:

                _h1_parent = self.addParent(absolute_parent,
                                            td[_key_h1]['name'],
                                            _key_h1)
                td[_key_h1]['ui'] = _h1_parent
                tree_ui['h1'].append(_h1_parent)

                for _key_h2 in td[_key_h1]['children'].keys():

                    # if there are children, we need to use addParent
                    if td[_key_h1]['children'][_key_h2]['children']:

                        _h2_parent = self.addParent(_h1_parent,
                                                    td[_key_h1]['children'][_key_h2]['name'],
                                                    _key_h2)
                        td[_key_h1]['children'][_key_h2]['ui'] = _h2_parent
                        tree_ui['h2'].append(_h2_parent)

                        for _key_h3 in td[_key_h1]['children'][_key_h2]['children']:
                            _h3_child = self.addChild(_h2_parent,
                                                      td[_key_h1]['children'][_key_h2]['children'][_key_h3]['name'],
                                                      _key_h3)
                            td[_key_h1]['children'][_key_h2]['children'][_key_h3]['ui'] = _h3_child

                            set_h_indexes(td[_key_h1]['children'][_key_h2]['children'][_key_h3], h3=h3_index)
                            tree_ui['h3'].append(_h3_child)
                            h3_index += 1

                    else:  # key_h2 has no children, it's a leaf
                        _h3_child = self.addChild(_h1_parent,
                                                  td[_key_h1]['children'][_key_h2]['name'],
                                                  _key_h2)
                        td[_key_h1]['children'][_key_h2]['ui'] = _h3_child
                        tree_ui['h2'].append(_h3_child)
                        tree_ui['h3'].append(None)
                        h3_index += 1

                    set_h_indexes(td[_key_h1]['children'][_key_h2], h2=h2_index)
                    h2_index += 1

            else:  # _key_h1 has no children, using addChild
                _child = self.addChild(absolute_parent,
                                       td[_key_h1]['name'],
                                       _key_h1)
                td[_key_h1]['ui'] = _child
                tree_ui['h1'].append(_child)
                tree_ui['h2'].append(None)
                tree_ui['h3'].append(None)
                h2_index += 1

            set_h_indexes(td[_key_h1], h1=h1_index)
            h1_index += 1
            h3_index += 1

            self.tree_ui = tree_ui

    def addParent(self, parent, title, name):
        item = QTreeWidgetItem(parent, [title])
        item.setData(self.tree_column, QtCore.Qt.UserRole, '')
        item.setChildIndicatorPolicy(QTreeWidgetItem.ShowIndicator)
        item.setCheckState(self.tree_column, QtCore.Qt.Checked)
        item.setExpanded(True)
        return item

    def addChild(self, parent, title, name):
        item = QTreeWidgetItem(parent, [title])
        item.setData(self.tree_column, QtCore.Qt.UserRole, '')
        item.setCheckState(self.tree_column, QtCore.Qt.Checked)
        return item

    def init_widgets(self):
        pass

    def apply_clicked(self):
        # do stuff
        self.close()

    def cancel_clicked(self):
        self.close()

    def closeEvent(self, eventhere=None):
        pass
        # print("Leaving Parameters Selection UI")


class SaveConfigInterface(QDialog):

    # config_dict = {}

    def __init__(self, parent=None, grand_parent=None):
        self.parent = parent
        self.grand_parent = grand_parent

        QDialog.__init__(self, parent=grand_parent)
        self.ui = UiDialogSave()
        self.ui.setupUi(self)

        self.ui.save_as_value.setPlaceholderText("undefined")

    def get_defined_name_config(self):
        return str(self.ui.save_as_value.text())

    def ok_clicked(self):
        name_config = self.get_defined_name_config()
        if name_config:
            self.parent.save_as_config_name_selected(name=name_config)
            self.grand_parent.ui.statusbar.showMessage("New configuration saved ({})".format(name_config), 8000)
            self.grand_parent.ui.statusbar.setStyleSheet("color: green")
            self.close()

    def cancel_clicked(self):
        self.close()


class ConfigHandler:
    '''This class takes care of the config dictionary manipulations'''

    @staticmethod
    def activate_this_config(key="", config={}):
        for _key in config:
            if _key == key:
                config[_key]['active'] = True
                break
        return config

    @staticmethod
    def deactivate_all_config(config={}):
        for _key in config:
            config[_key]['active'] = False
        return config

    @staticmethod
    def lazy_export_config(config_dict={}):
        with open(CONFIG_FILE, 'wb') as handle:
            full_config = {}
            full_config['configurations'] = config_dict
            pickle.dump(full_config,
                        handle,
                        protocol=pickle.HIGHEST_PROTOCOL)

    @staticmethod
    def remove_this_config(key="", config={}):
        new_config = OrderedDict()
        for _key in config:
            if _key == key:
                pass
            else:
                new_config[_key] = config[_key]
        return new_config


class H3TableHandler:
    # object that takes care of handling the config object
    o_save_config = None
    config_dict = {}

    def __init__(self, parent=None):
        self.parent = parent

    def retrieve_previous_configurations(self):
        if os.path.exists(CONFIG_FILE):
            with open(CONFIG_FILE, 'rb') as handle:
                _cfg = pickle.load(handle)

                try:
                    config_dict = _cfg['configurations']
                except KeyError:
                    return

            self.parent.config_dict = config_dict

    def save_as_config(self):
        o_save_config = SaveConfigInterface(parent=self,
                                            grand_parent=self.parent)
        o_save_config.show()
        self.o_save_config = o_save_config

    def save_as_config_name_selected(self, name=''):
        self.create_config_dict(name=name)
        self.export_config()

    def create_config_dict(self, name=''):
        if name == '':
            name = 'undefined'

        o_current_table_config = TableConfig(parent=self.parent)
        current_config = o_current_table_config.get_current_config()

        inside_dict = OrderedDict()
        inside_dict['table'] = current_config
        inside_dict['active'] = True

        # retrieve previous config file
        previous_config_dict = self.parent.config_dict
        if previous_config_dict == {}:
            # first time
            new_full_config = OrderedDict()
            new_full_config[name] = inside_dict
        else:
            self.deactivate_all_config()
            old_full_config = self.parent.config_dict
            # list_keys = old_full_config.keys()
            old_full_config[name] = inside_dict
            new_full_config = old_full_config

        self.config_dict = new_full_config

    def deactivate_all_config(self):
        old_full_config = self.parent.config_dict
        for _key in old_full_config:
            old_full_config[_key]['active'] = False
        self.parent.config_dict = old_full_config

    def export_config(self):
        config_dict = self.config_dict
        with open(CONFIG_FILE, 'wb') as handle:
            full_config = {}
            full_config['configurations'] = config_dict
            pickle.dump(full_config,
                        handle,
                        protocol=pickle.HIGHEST_PROTOCOL)

    def save_config(self):
        active_config_name = self.parent.active_config_name
        self.save_as_config_name_selected(name=active_config_name)

    def reset_table(self):
        config_dict = self.parent.config_dict
        if not ("FULL_RESET" in config_dict):
            config_dict['FULL_RESET'] = self.parent.reset_config_dict
            self.parent.config_dict = config_dict

        ConfigHandler.lazy_export_config(config_dict=self.parent.config_dict)
        self.parent.load_this_config(key='FULL_RESET', resize=True)

    def right_click(self):
        self.retrieve_previous_configurations()
        previous_config = self.parent.config_dict

        if previous_config == {}:
            list_configs = []
        else:
            list_configs = previous_config.keys()

        top_menu = QMenu(self.parent)

        menu = top_menu.addMenu("Menu")
        config = menu.addMenu("Configuration ...")

        _save = config.addAction("Save")

        _save_as = config.addAction("Save As ...")

        list_signal_config_files = []
        list_signal_remove_config = []
        list_config_displayed = []

        save_state = False
        if not list_configs == []:
            config.addSeparator()
            for _label in list_configs:

                if _label == "FULL_RESET":
                    continue

                this_one_is_active = False

                if previous_config[_label]['active']:
                    self.parent.active_config_name = _label
                    _full_label = u"\u2713 " + _label
                    save_state = True
                    this_one_is_active = True

                else:
                    _full_label = u"\u200b   \u200b " + _label

                list_config_displayed.append(_label)
                temp = config.addMenu(_full_label)
                if not this_one_is_active:
                    temp_select = temp.addAction("Select")
                else:
                    temp_select = temp.addAction("Reload")
                list_signal_config_files.append(temp_select)

                temp_remove = temp.addAction("Remove")
                list_signal_remove_config.append(temp_remove)

        # disable "save" button if we don't have any config activated
        _save.setEnabled(save_state)

        self.parent.list_config_displayed = list_config_displayed
        menu.addSeparator()
        _reset = menu.addAction("Full Reset Table/Tree")

        action = menu.exec_(QtGui.QCursor.pos())

        if action == _save_as:
            self.save_as_config()
            return

        elif action == _save:
            self.save_config()
            return

        elif action == _reset:
            self.reset_table()
            return

        if not (list_signal_config_files == []):

            # user clicked to select config
            for _index, _signal in enumerate(list_signal_config_files):
                if action == _signal:
                    self.activate_this_config(config=list_config_displayed[_index])

        if not (list_signal_remove_config == []):

            # user clicked to remove config
            for _index, _signal in enumerate(list_signal_remove_config):
                if action == _signal:
                    self.remove_this_config(config=list_config_displayed[_index])

    def remove_this_config(self, config):
        config_dict = ConfigHandler.remove_this_config(config=self.parent.config_dict,
                                                       key=config)
        self.parent.config_dict = config_dict
        # import pprint
        # pprint.pprint(config_dict)
        ConfigHandler.lazy_export_config(config_dict=config_dict)

    def activate_this_config(self, config):
        config_dict = ConfigHandler.deactivate_all_config(config=self.parent.config_dict)
        config_dict = ConfigHandler.activate_this_config(config=config_dict,
                                                         key=config)
        self.parent.config_dict = config_dict
        ConfigHandler.lazy_export_config(config_dict=config_dict)
        self.parent.load_this_config(key=config)


class TableConfig:
    '''This class will look at the h1, h2 and h3 table to create the config use width and visibility of each column'''

    def __init__(self, parent=None):
        self.parent = parent

    def get_current_config(self):
        current_config_dict = {}
        current_config_dict['h1'] = self.__get_current_table_config(table='h1')
        current_config_dict['h2'] = self.__get_current_table_config(table='h2')
        current_config_dict['h3'] = self.__get_current_table_config(table='h3')
        return current_config_dict

    def __get_current_table_config(self, table='h1'):

        if table == 'h1':
            table_ui = self.parent.ui.h1_table
        elif table == 'h2':
            table_ui = self.parent.ui.h2_table
        else:
            table_ui = self.parent.ui.h3_table

        nbr_column = table_ui.columnCount()
        _dict = {}
        for _col in np.arange(nbr_column):
            _width = table_ui.columnWidth(_col)
            _visible = not table_ui.isColumnHidden(_col)
            _dict[_col] = {'width': _width,
                           'visible': _visible}

        return _dict


def main():
    app = PyQt4.QtGui.QApplication(sys.argv)
    app.setOrganizationName("Qtrac Ltd.")
    app.setOrganizationDomain("qtrac.eu")
    app.setApplicationName("Image Changer")
    app.setWindowIcon(PyQt4.QtGui.QIcon(":/icon.png"))
    form = MainWindow()
    form.show()
    app.exec_()

if __name__ == '__main__':
    main()
